# ADR-001: Use UUIDv5 for Node and Type Identifiers

## Status
ACCEPTED

## Context
Currently, `NodeId` and `TypeId` are defined as `usize`. These IDs are generated by simple incrementing counters within the `VisitorState` during parsing. This approach has several limitations:
1.  **Instability:** IDs are not stable across different parsing runs, making it difficult to compare graphs generated at different times or track items across changes.
2.  **Parallelism Conflicts:** When parsing files in parallel, managing a single atomic counter for IDs can become a bottleneck or require complex synchronization. Independent counters per thread would lead to ID collisions when merging results.
3.  **Graph Merging:** Merging `CodeGraph` instances from different sources (e.g., incremental parsing, distributed processing) is impossible with conflicting or meaningless `usize` IDs.
4.  **Lack of Meaning:** The `usize` IDs carry no inherent information about the node or type they represent.
5.  **Incremental Updates:** Tracking changes efficiently requires stable identifiers.

## Decision
We will change `NodeId` and `TypeId` to use `uuid::Uuid`, stored natively in CozoDB via `cozo::DataValue::Uuid`. We will use **UUID version 5**, which generates UUIDs based on the SHA-1 hash of a namespace identifier and a name.

-   **Namespaces:**
    -   A single, constant `PROJECT_NAMESPACE: Uuid` will be defined for the `ploke` project.
    -   For each parsed crate, a `CRATE_NAMESPACE: Uuid` will be derived: `Uuid::new_v5(&PROJECT_NAMESPACE, format!("{}@{}", crate_name, crate_version).as_bytes())`. This namespace isolates IDs per crate version.

-   **Identifier Structures:**
    -   **`NodeId`:** Will be an enum to handle stable and unstable paths:
        -   `NodeId::Path(Uuid)`: For items with stable paths (functions, structs, enums, modules, etc.). Generated as `Uuid::new_v5(&CRATE_NAMESPACE, absolute_item_path.as_bytes())`, e.g., `"my_crate::module::MyStruct"`.
        -   `NodeId::Synthetic(Uuid)`: Fallback for items without stable paths (e.g., macro-generated items, complex closures). Generated as `Uuid::new_v5(&CRATE_NAMESPACE, format!("{}:{}-{}:{}", file_path, start_byte, end_byte, context_hint).as_bytes())`.
    -   **`TypeId`:** Will be a struct containing crate context and type structure hash:
        -   `crate_id: Uuid`: The `CRATE_NAMESPACE` UUID for the defining crate.
        -   `type_id: Uuid`: Generated as `Uuid::new_v5(&CRATE_NAMESPACE, canonical_type_string.as_bytes())`.
        -   *Note:* Initial implementation of `canonical_type_string` will use normalized `to_token_stream()` output, acknowledging limitations in full path/alias resolution via `syn` alone.
    -   **`LogicalTypeId`:** A separate `Uuid` field associated with types, used for stable linking across crate versions, primarily for embeddings. Generated as `Uuid::new_v5(&PROJECT_NAMESPACE, format!("{}::{}", crate_name, type_path_within_crate).as_bytes())`.
    -   **`TrackingHash`:** A separate `Uuid` field on relevant nodes (`FunctionNode`, `StructNode`, etc.) for detecting content changes independent of formatting. Generated as `Uuid::new_v5(&CRATE_NAMESPACE, format!("{}:{}", file_path, ast_token_hash).as_bytes())`, where `ast_token_hash` ignores whitespace/comments. (Alternative: Use a faster non-crypto hash like `ahash` outputting `u128`/`Bytes`).

-   **Processing Model (Initial Implementation):**
    -   A **Multi-Phase Batch Processing Model** will be used:
        1.  **Discovery:** Identify files, determine crate structure/versions, establish namespaces.
        2.  **Parallel Parse:** Parse files concurrently. Generate *temporary* `Synthetic` IDs and unresolved type references within partial `CodeGraph`s.
        3.  **Batch Resolution:** Merge partial graphs. Build the definitive module tree. Resolve temporary IDs to final `NodeId::Path` or `TypeId`. Resolve type references. Update relations.
        4.  **Embedding Generation:** Generate embeddings based on `LogicalTypeId`.
        5.  **Transform & Insert:** Convert the resolved graph and embeddings into Cozo `DataValue`s (using native `Uuid`, `Vector`) and insert/update into CozoDB.
    -   **Persisted State:** The outputs of Phase 3 (module tree, ID mappings `Synthetic -> Path`) will be persisted. Subsequent runs will load this state to accelerate Phase 3 for incremental updates, avoiding full re-resolution where possible.

-   **Dependency:** The `uuid` crate (version 1.x or later) will be added as a dependency to relevant crates (`syn_parser`, `ploke-graph`, `ploke-db`, `test-utils`), with the `v5` and `serde` features enabled.

-   **Feature Flag:** Implementation will occur behind a Cargo feature flag named `uuid_ids`.

## Consequences
-   **Positive:**
    -   **Stable IDs:** `NodeId::Path` and `LogicalTypeId` provide stability across runs and some refactoring. `TypeId` provides stability within a specific crate version.
    -   **Mergeable Graphs:** Deterministic IDs allow merging data from parallel parsers.
    -   **Parallelism:** UUIDs can be generated independently (with correct context), enabling parallel parsing (Phase 2).
    -   **Incremental Updates:** The batch model combined with persisted resolution state allows for more efficient processing of subsequent changes compared to full rescans. `TrackingHash` enables content change detection.
    -   **Embedding Stability:** `LogicalTypeId` reduces unnecessary re-embedding when dependencies update without semantic type changes.
    -   **Database Efficiency:** Using Cozo's native `Uuid` type is more efficient for storage and querying than string representations.
-   **Negative:**
    -   **Refactoring Effort:** Requires significant changes across multiple crates and tests.
    -   **Complexity:** The multi-phase batch model, especially the resolution phase (Phase 3), is complex. Canonical type string generation has initial limitations. `TrackingHash` requires AST token processing.
    -   **Performance:** UUID generation is slower than counters. Resolution phase adds latency.
    -   **Storage Size:** `Uuid` (16 bytes) is larger than `usize`.
-   **Neutral:**
    -   Fundamental representation changes from `usize` to `Uuid`.
    -   Requires careful state management for the persisted resolution data.

## Compliance
[PROPOSED_ARCH_V3.md](/PROPOSED_ARCH_V3.md) Items: Aligns with the goal of parsing code into a graph database and supports the overall architecture. Enables parallel processing domains.
[IDIOMATIC_RUST.md](ai_workflow/AI_Always_Instructions/IDIOMATIC_RUST.md) Sections:
    - C-COMMON-TRAITS: `uuid::Uuid` implements standard traits.
    - C-SERDE: `uuid::Uuid` supports `serde`.
    - C-NEWTYPE: `NodeId`, `TypeId`, `LogicalTypeId` act somewhat like newtypes providing static distinctions, although `NodeId` is an enum and `TypeId` a struct.
[CONVENTIONS.md](ai_workflow/AI_Always_Instructions/CONVENTIONS.md) Items:
    - Type System: `uuid::Uuid` derives `Send + Sync`. Our wrapper types (`NodeId`, `TypeId`) will also be `Send + Sync`.
