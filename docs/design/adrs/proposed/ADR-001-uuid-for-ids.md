# ADR-001: Use UUIDv5 for Node and Type Identifiers

## Status
PROPOSED

## Context
Currently, `NodeId` and `TypeId` are defined as `usize`. These IDs are generated by simple incrementing counters within the `VisitorState` during parsing. This approach has several limitations:
1.  **Instability:** IDs are not stable across different parsing runs, making it difficult to compare graphs generated at different times.
2.  **Parallelism Conflicts:** When parsing files in parallel, managing a single atomic counter for IDs can become a bottleneck or require complex synchronization. Independent counters per thread would lead to ID collisions when merging results.
3.  **Graph Merging:** Merging `CodeGraph` instances from different sources (e.g., incremental parsing, distributed processing) is impossible with conflicting or meaningless `usize` IDs.
4.  **Lack of Meaning:** The `usize` IDs carry no inherent information about the node or type they represent.

## Decision
We will change `NodeId` and `TypeId` to use `uuid::Uuid`. Specifically, we will use **UUID version 5**, which generates UUIDs based on the SHA-1 hash of a namespace identifier and a name.

-   **Namespace Strategy:**
    -   For **Nodes** (`NodeId`): The namespace will be derived from the fully qualified module path (e.g., `crate::module::submodule`). The "name" component for the UUID generation will be a combination of the item's type (struct, fn, etc.) and its name (or potentially its source span for unnamed items like some impl blocks). This ensures items within the same module but with different names get unique IDs, and items with the same name in different modules also get unique IDs.
    -   For **Types** (`TypeId`): A fixed, predefined UUID namespace will be used specifically for types. The "name" component will be the canonical string representation of the type (e.g., `std::vec::Vec<std::string::String>`). This ensures the same type structure always resolves to the same `TypeId`, regardless of where it's encountered.
-   **Dependency:** The `uuid` crate (version 1.x or later) will be added as a dependency, with the `v5` and `serde` features enabled.

## Consequences
-   **Positive:**
    -   **Stable IDs:** IDs will be consistent across different parsing runs as long as the source code (module path, item name, type structure) remains the same.
    -   **Mergeable Graphs:** `CodeGraph` instances can be safely merged as IDs are globally unique and deterministic.
    -   **Parallelism:** UUIDs can be generated independently in parallel threads without coordination, eliminating bottlenecks and collision risks associated with shared counters.
    -   **Global Uniqueness:** UUIDs provide a high degree of confidence in global uniqueness.
-   **Negative:**
    -   **Refactoring Effort:** Requires significant changes across multiple crates (`syn_parser`, `ploke-graph`, `ploke-db`, `test-utils`) and tests.
    -   **Storage Size:** `Uuid` (16 bytes) is larger than `usize` (typically 8 bytes), increasing memory usage for the `CodeGraph` and potentially database storage size (if stored natively; likely stored as 36-char string).
    -   **Performance:** UUID generation involves hashing and is slower than incrementing a counter. Comparisons might also be slightly slower.
    -   **Database Schema:** The database schema (`ploke-graph`) must be updated to store UUIDs, likely as strings, impacting storage and indexing.
    -   **Serialization:** Serialization formats (RON) need to handle UUIDs.
-   **Neutral:**
    -   The fundamental representation of code elements changes from integer IDs to UUIDs.

## Compliance
[PROPOSED_ARCH_V3.md](/PROPOSED_ARCH_V3.md) Items: (N/A - This ADR precedes formal architecture versions)
[IDIOMATIC_RUST.md](ai_workflow/AI_Always_Instructions/IDIOMATIC_RUST.md) Sections:
    - C-COMMON-TRAITS: `Uuid` implements standard traits like `Clone`, `Eq`, `Hash`, `Debug`, `Display`, `Send`, `Sync`.
    - C-SERDE: `Uuid` supports `serde` via a feature flag.
[CONVENTIONS.md](ai_workflow/AI_Always_Instructions/CONVENTIONS.md) Items:
    - Type System: `Uuid` derives `Send + Sync`, aligning with the convention for core data structures.
