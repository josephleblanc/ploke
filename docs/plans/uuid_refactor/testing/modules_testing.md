
**Core Testing Objectives for `ModuleNode` (Phase 2):**

1.  **Node Existence & Identification:**
    *   Verify that `ModuleNode`s are created for all expected module definitions (`FileBased`, `Inline`) and declarations (`Declaration`) within each parsed file.
    *   **Rigorously** use the `find_*_node_paranoid` helpers (e.g., `find_file_module_node_paranoid`, `find_inline_module_node_paranoid`, `find_declaration_node_paranoid`) to locate these nodes, ensuring correct context (file path, expected module path) is provided to the helpers. Assert that exactly one node matches the criteria within the specific file's graph.
    *   Verify the generated `NodeId::Synthetic` by comparing it against the ID regenerated by the paranoid helper, ensuring consistency with context (namespace, file path, parent path, name, span).

2.  **Node Properties:**
    *   Assert the correctness of fundamental properties for *each* located `ModuleNode`:
        *   `name`: Matches the expected module identifier.
        *   `path`: Accurately reflects the module's **canonical logical path** (e.g., `["crate", "top_mod", "nested_mod"]`).
        *   `visibility`: Matches the visibility specified in the source code (`Public`, `Private`, `Crate`, `Restricted`, etc.).
        *   `span`: Correctly identifies the byte offsets for the node's definition (file-level span might be (0,0) currently, inline span, declaration span).
        *   `attributes`, `docstring`: Correctly parsed and stored.
        *   `tracking_hash`: Present (`Some(Uuid)`) for definition nodes (potentially `None` for declarations or file-level roots depending on implementation).

3.  **`ModuleDef` Variant Correctness:**
    *   Assert that the correct `ModuleDef` variant (`FileBased`, `Inline`, `Declaration`) is assigned.
    *   For `FileBased`: Verify `file_path`, `file_attrs`, `file_docs`.
    *   For `Inline`: Verify `inline_span`.
    *   For `Declaration`: Verify `declaration_span`, `resolved_definition` (should be `None` in Phase 2).

4.  **Containment (`ModuleNode.items`):**
    *   For `FileBased` and `Inline` modules, **strictly** verify the contents of the `items` vector.
    *   Ensure it contains the `NodeId::Synthetic` for *all* items (functions, structs, enums, sub-modules (inline or declarations), imports, etc.) defined *directly* within that module *in that specific file*.
    *   Assert exact counts and presence of expected IDs. Use paranoid helpers to find the IDs of the contained items for comparison.
    *   This serves as the primary, validated source for containment information in Phase 2.

5.  **Imports (`ModuleNode.imports`):**
    *   Verify the `imports` vector contains the `ImportNode` structs corresponding to `use` and `extern crate` statements found within that module.
    *   Assert correct count and potentially check properties of the contained `ImportNode`s (like path, visible name).

6.  **Relations (`RelationKind::Contains` - Preliminary):**
    *   As a secondary check, verify that `RelationKind::Contains` exists in the *same partial graph* where the parent and child are defined.
    *   The `source` must be the `GraphId::Node` of the parent `ModuleNode`.
    *   The `target` must be the `GraphId::Node` of a child item (function, struct, submodule declaration, etc.) whose ID is *also* present in the parent's `items` list.
    *   Assert that the source is *always* a `ModuleNode` ID.
