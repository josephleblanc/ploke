# Todo Dec 18, 2025

## Problem
- `/load <crate>` still rebuilds indices for the default local MiniLM (384) set in several call paths (`ploke_db::multi_embedding::load_db`, rag/ingest helpers), ignoring the restored embedding set.
- The TUI load path updates only `Database.active_embedding_set`; the embedder runtime stays on the startup default, so post-load embeddings can have wrong dims/provider.
- Active-set metadata is persisted only via the TUI save flow; other backup entry points omit it, so restore may fall back to the wrong set.

## Repro (today)
1) `/embedding search <mode>` and select a non-default model  
2) `/index start <crate>`  
3) `/save db`  
4) Restart `ploke-tui`  
5) `/load <crate>` → indices rebuilt for default set; restored vectors for chosen set are not used.

## Plan
- [ ] Restore path parity: update `ploke_db::multi_embedding::load_db` (and rag/ingest callers) to reuse the same active-set restoration logic as the TUI load path and pass the chosen set into index creation.
- [ ] Selection policy: when multiple populated sets exist, pick the first populated set deterministically, log and surface the choice in the UI (no silent selection).
- [ ] Runtime rehydration: on load, reconfigure the embedder runtime to the restored set (or warn/fallback if unavailable) instead of leaving the default processor active. If the DB already has a populated vector set that differs from the startup/default selection, adopt the DB’s set and surface the switch in UI/logs.
- [ ] Shared restore helper: centralize “import + choose set + set DB + rehydrate runtime” so TUI, rag, and ingest reuse one code path.
- [ ] Persist metadata everywhere: ensure all backup entry points write the active-set metadata before backup, not just the TUI `/save db`.
- [ ] Index creation API: add an explicit `create_index_for_set(&Database, &EmbeddingSet)` (with a temporary shim to the current default-based helper) so restore can target the chosen set without implicit defaults; update callers accordingly.
- [ ] Tests: add integration tests that (a) restore a backup with a non-default set through both TUI and library load helpers, (b) assert active set and embedder runtime match the restored set, (c) verify indices/HNSW are built for the restored set, not the default, and (d) legacy backup (no metadata) surfaces an error in UI/logs.

## Open Questions
- Where to store the “active set” marker in the DB/backup (reuse `crate_context` meta vs. new `db_meta` row)?
- How to prompt/choose when multiple sets exist in the backup (CLI flag vs. interactive chooser)?
