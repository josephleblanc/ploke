# Implementation Plan — OpenRouter Model/Provider Integration + Model Browser (Phase 2)

Linkage
- Source instructions: `AGENTS.md` (Ongoing Plan) and `crates/ploke-tui/docs/feature/model-provider-select/plan_deep_integration.md`.
- This plan governs the next implementation phase. Implementation logs will be created as `docs/plans/agentic-system-plan/impl-plan/impl_20250830-064828Z.md` and will link back here.

## Objectives and Scope
- Strongly typed OpenRouter integration across `/models` and `/models/:author/:model/endpoints` with minimal allocations and early validation.
- Parse and normalize `supported_parameters`, `pricing`, `canonical_slug` → `ProvEnd` (author+model), `top_provider`, and key architecture details.
- Build a persistent model/capabilities cache suitable for fast TUI operations and filtering.
- Deliver Phase 2.1–2.2 of the Model Browser: list + search + set active, and filters/details expansion.
- Establish tests and evidence discipline (offline by default; live under `cfg(feature = "live_api_tests")`).

## Proposed Steps, Rationale, Acceptance Criteria

1) Type Foundations + `ProvEnd` Deserialize
- Rationale: One source of truth prevents drift and stringly-typed plumbing.
- Actions:
  - Implement `Deserialize` for `ProvEnd` from `canonical_slug` ("author/model"). Add `Display`, `FromStr`, and reuse existing `TryFrom<&Url>`.
  - Reconcile pricing types: prefer a single `Pricing` struct reused by catalog and endpoints (migrate from `ModelPricing` where feasible). Keep a deprecated alias if needed with clear deprecation.
  - Ensure `SupportedParameters` covers observed values (keep `snake_case`), and add `SupportsTools` helpers already in-use.
- Acceptance:
  - Unit tests: round-trip `ProvEnd` from slug; parse errors for invalid forms; `Pricing` parses both string/number inputs using `utils::de` helpers.
  - No duplicate pricing types in public API of `openrouter` module (or explicit deprecation noted).

2) Endpoint Fetch + Raw Capture
- Rationale: Capture ground-truth shapes for analysis and future schema hardening.
- Actions:
  - Implement `ProvEnd::call_endpoint` minimal GET with headers; return JSON `Value`.
  - Implement `persist_resp_raw(&self)` to write captured JSON to `crates/ploke-tui/data/endpoints/{author}/{model}-{ts}.json` (ts = short UTC). Log the path via tracing.
- Acceptance:
  - Live test (gated): call a known model and persist; asserts 200 and file creation.
  - Offline test: path formatting/unit asserts without network.

3) Catalog Fetch → Capabilities Cache
- Rationale: TUI needs fast, filtered view across providers/models.
- Actions:
  - Use `openrouter_catalog::fetch_models` to populate a `CapabilitiesCache` (id → minimal capability/pricing/tools/context summary). Favor zero-copy where possible.
  - Compute `supports_tools` via `supported_parameters` and provider overrides.
- Acceptance:
  - Offline unit test loading saved JSON fixture and producing cache entries with expected fields.

4) Shape Analysis Artifacts
- Rationale: Evidence-driven schema decisions and enum capture.
- Actions:
  - Run `json_visitor::explore_file_visit` on full model JSON and write artifacts under `target/test-output/openrouter/` (text + JSON). Keep existing helpers but redirect outputs off repo by default for tests.
- Acceptance:
  - Test produces artifacts; plan and logs reference their locations. No large artifacts committed by default.

5) Model Browser UI (Phase 2.1–2.2)
- Rationale: Deliver user-facing selection and filtering first.
- Actions:
  - Add `app/view/components/model_browser.rs` with state: `search_query`, `filters`, `selected_index`, `expanded`, `list_items`, `fetch_status`.
  - Implement `prepare`, `apply_filters_and_search`, `render`, and `handle_key` basics. Integrate with EventBus to receive refresh completion event and set active model.
  - Use substring search initially (no new deps); keep fuzzy matching as follow-up.
- Acceptance:
  - Users can open browser, search, navigate, and set active model. Filter toggles visible; basic details expand.

6) Tests, Gates, Evidence
- Rationale: Non-negotiable evidence discipline with clear gates.
- Actions:
  - Unit tests for: `ProvEnd` parsing, pricing coercions, endpoint URL formation, `supports_tools` computation.
  - Live tests behind `live_api_tests` and `test_harness` feature as applicable.
  - CI-friendly offline tests using fixtures; write deeper artifacts to `target/test-output/...`.
- Acceptance:
  - Summarize pass/fail/ignored counts in impl logs; do not claim live readiness unless live path ran.

7) Documentation
- Rationale: Maintain strong developer ergonomics and future-proofing.
- Actions:
  - Add module-level docs for `openrouter` submodules per rustdoc rules; extend `docs/openrouter/request_structure.md` with confirmed shapes/edge-cases.
  - Document error cases and coercions; mark any temporary `#[serde(untagged)]` usage as deprecated bridge (if used).
- Acceptance:
  - Docs exist and compile (`cargo doc` locally); comments adhere to `//!` vs `///` rules.

## Deliverables
- Strongly typed OpenRouter integration (catalog + endpoints) with unified pricing and `ProvEnd` deserialization.
- Capabilities cache feeding the Model Browser.
- Model Browser (Phase 2.1–2.2): list/search/set-active, filters+details.
- Tests (offline + gated live) and analysis artifacts in `target/test-output/openrouter/`.
- Implementation log linked to this plan.

## Validation Approach
- Offline: unit/integration tests covering parsing, cache formation, UI logic; artifacts under `target/test-output/openrouter/`.
- Live: gated tests exercise `/models` and at least one `/endpoints` call; record brief summary (counts + key properties) in impl log; do not count skipped as pass when live gate is ON.
- Evidence for readiness: include pass/fail/ignored counts and artifact paths in the impl log.

## Open Questions / Risks
- Pricing type unification: migrate now vs. keep alias (`ModelPricing`) for a short bridge period? Proposed: unify now; add a deprecated alias to avoid churn.
- Persistent registry format/location: confirm path and redaction rules for any API-derived data that we cache.
- Strictness policy wiring (OpenRouterOnly/AllowCustom/AllowAny): confirm placement in config and UI surface.
- Any UI dependencies beyond ratatui that need review (e.g., fuzzy matcher) — proposed to defer until 2.3.
