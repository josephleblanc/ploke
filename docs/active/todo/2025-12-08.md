# Todo

## Overarching goal: partial vector embedding updates

### Task 1: Impl block handling

`impl` blocks are a pain in the ass, because:
- They don't have a module path, so there is not clear way to refer to them
- There can be multiple impl blocks for a given struct

In terms of database representation, this means Impl blocks need to be special.

We could try to sidestep the issue of impl blocks, but we need a way to be able
to differentiate between the impl blocks, and to be able to have a target that we can write to for the LLM>

However, what we can do is mostly sidestep the issue by storing the byte
offsets for each of the code items within the context of the impl and following
the current process of hashing each of the associated items with the name of
the defining item.

How, in order for us to be able to know which struct or trait we can link the
impl to, we need to be able to link the type of the Self to the impl nodes. 

That is what we will want to do longer term in any case, but we can't get side-tracked with implementing type resolution just yet. Instead, we can just handle generating the synthetic node ids, except we are going to need to have the resolved type in order to get the canonical path to each of the methods.

The canonical path is necessary for the methods, at least to some extent. But these are not indicative of the syntactic location of the code items, and so are not directly relevant to solving the problem of being able to locate the implementation nodes in order to edit them or differentiate different impl blocks.

Instead, we are going to move forward by generating a "canonical" id for the methods such that we have a unique identifier that we can use to identify the code items, and to differentiate them from other possible items within the same crate (this will even be reliable, to an extent, across crates due to using a different namespace). This canonical id is only important insofar as it proides a relatively unchanging target to compare the synthetic node id and tracking hash against.

Then we can create a data structure that can hold on to the triple pairing of the:

1. NodeId(canonical)
2. NodeId(synthetic)
3. TrackingHash

The canonical nodeId will only be formed of the module path, without the file
file path, and the namespace of the defining crate. These do not need to be
capable of being enerated independently, since we can assume that by the time
we generate the canonical module ids, we will have access to the module tree.

So then the problem with the impl nodes will be that they have the same
canonoical node id, which is actually fine. They will have another node that
forms the impl block itself, which is itself just an intermediary for the typed
item in any case, and the impl block as a whole does not really need to be
processed into a vector embedding separately.

So in the immediate future, I need to handle the uniqueness problem of impl
nodes in the synthetic node id generation.

Which should just require creating an extra number that can differentiate its
number within the ordering in the target file.

#### Chosen solution:

Either:

1. add a new field to the `ImplNode`
  - could use a method that returns the new field and/or add a new type that
  could encompass both the `ImplNodeId` and the byte start (and/or byte end).

-- or --

2. add a method to the `ImplNodeId` that has a particular method that is
   special for only `ImplNodeId`

-- or --

3. also can potentially compare the byte offsets of the node items (but not the
   `ImplNodeId` on its own)

### Task 2: CanonId finalization

This still needs some planning and thought.

Some ideas:

1. After the module tree is pruned and we finalize the set of items that are
   going to be used for the transform and have the canonical node path, we can
   just generate an id then.

2. 

### Task 3: Update scan_for_change && tui
