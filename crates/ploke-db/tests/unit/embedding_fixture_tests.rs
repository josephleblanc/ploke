use ploke_db::ext::embed_utils::{DbEmbedUtils, HasNullEmbeds};
use ploke_db::{
    hnsw_of_type,
    multi_embedding::schema::vector_dims::sample_vector_dimension_specs,
    Database,
    DbError,
    NodeType,
};
use ploke_error::Error as PlokeError;
use ploke_test_utils::{
    workspace_root, LEGACY_FIXTURE_BACKUP_REL_PATH, MULTI_EMBED_FIXTURE_BACKUP_REL_PATH,
};

/// Verifies that the legacy `fixture_nodes` backup contains a non-null dense
/// embedding for the `TOP_LEVEL_BOOL` constant.
#[test]
fn legacy_fixture_has_embedding_for_top_level_bool() -> Result<(), PlokeError> {
    let mut target_file = workspace_root();
    target_file.push(LEGACY_FIXTURE_BACKUP_REL_PATH);

    let db = Database::init_with_schema()?;
    let prior_rels_vec = db.relations_vec()?;

    db.import_from_backup(&target_file, &prior_rels_vec)
        .map_err(DbError::from)
        .map_err(PlokeError::from)?;

    let rows = db.get_null_embedding_rows("TOP_LEVEL_BOOL", NodeType::Const)?;

    assert_eq!(
        rows.rows.len(),
        1,
        "expected exactly one const row for TOP_LEVEL_BOOL"
    );

    let is_null_embedding = rows.is_null_embedding()?;

    assert!(
        !is_null_embedding,
        "expected TOP_LEVEL_BOOL to have a non-null legacy embedding"
    );

    Ok(())
}

/// Sanity check that HNSW search over consts returns at least one hit for the
/// legacy `fixture_nodes` backup after indexes are created.
#[test]
fn legacy_hnsw_returns_any_consts_in_fixture() -> Result<(), PlokeError> {
    let mut target_file = workspace_root();
    target_file.push(LEGACY_FIXTURE_BACKUP_REL_PATH);

    let db = Database::init_with_schema()?;
    let prior_rels_vec = db.relations_vec()?;

    db.import_from_backup(&target_file, &prior_rels_vec)
        .map_err(DbError::from)
        .map_err(PlokeError::from)?;

    let model = sample_vector_dimension_specs()
        .first()
        .expect("vector spec")
        .embedding_model()
        .clone();
    ploke_db::create_index_primary(&db, model.clone()).map_err(PlokeError::from)?;

    let hits = hnsw_of_type(&db, NodeType::Const, 10, 40, model)?;
    assert!(
        !hits.is_empty(),
        "expected HNSW search over consts to return at least one hit"
    );

    Ok(())
}

/// Explicitly documents which combinations of schema features and fixture
/// backups are expected to succeed when importing Cozo backups.
#[cfg(not(feature = "multi_embedding"))]
#[test]
fn backup_import_compat_legacy_schema() -> Result<(), PlokeError> {
    let mut legacy_path = workspace_root();
    legacy_path.push(LEGACY_FIXTURE_BACKUP_REL_PATH);

    let mut multi_path = workspace_root();
    multi_path.push(MULTI_EMBED_FIXTURE_BACKUP_REL_PATH);

    let db = Database::init_with_schema()?;
    let prior_rels_vec = db.relations_vec()?;

    let legacy_result = db
        .import_from_backup(&legacy_path, &prior_rels_vec)
        .map_err(DbError::from);
    assert!(
        legacy_result.is_ok(),
        "legacy schema should be able to import legacy backup"
    );

    let multi_result = db
        .import_from_backup(&multi_path, &prior_rels_vec)
        .map_err(DbError::from);
    assert!(
        multi_result.is_ok(),
        "legacy schema should currently be able to import the multi-embedding backup as generated by test fixtures"
    );

    Ok(())
}

/// Under the multi-embedding schema feature, importing the multi-embedding
/// backup must succeed so downstream tests relying on runtime-owned relations
/// have a well-defined starting point.
#[cfg(feature = "multi_embedding")]
#[test]
fn backup_import_compat_multi_schema() -> Result<(), PlokeError> {
    let mut multi_path = workspace_root();
    multi_path.push(MULTI_EMBED_FIXTURE_BACKUP_REL_PATH);

    let db = Database::init_with_schema()?;
    let prior_rels_vec = db.relations_vec()?;

    let result = db
        .import_from_backup(&multi_path, &prior_rels_vec)
        .map_err(DbError::from);

    assert!(
        result.is_ok(),
        "multi-embedding schema should be able to import multi-embedding backup"
    );

    Ok(())
}
