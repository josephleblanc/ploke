# ploke-db Code Review — 2025-08-19

Scope
- Crate: crates/ploke-db
- Focus: API ergonomics, correctness, performance, consistency, error handling, testing, and maintainability
- This review is descriptive and prescriptive. It calls out strengths, risks, and concrete fix suggestions (with references to file paths and functions). No code changes are made in this review.

Summary
- The crate provides a solid foundation for code-graph querying over CozoDB, HNSW index management for vector search, and an in-memory BM25 scoring path. The architecture is modular: query builder, results, database access, indices, and callbacks are separated cleanly.
- There are a handful of correctness bugs and fragile string-construction paths for Cozo scripts that merit immediate attention.
- Tokenization and indexing are thoughtfully designed, but there is duplication and potential drift between two tokenizers.
- Tests are extensive and helpful; adding a few more targeted tests will catch the high-priority bugs called out below.

Top Strengths
- Clear separation of concerns:
  - Database access and script execution in database.rs
  - Query construction in query/builder.rs
  - Indexing (HNSW + BM25) under index/ and bm25_index/
  - Results formatting/typing in result/
  - Callback orchestration in query/callbacks.rs
- Good use of helper conversions (to_uuid, to_string, to_usize) and QueryResult adapter methods (to_embedding_nodes, try_into_file_data).
- Strong and growing test coverage, including async tests and realistic database restores in bm25_index/tests.
- Practical ergonomics:
  - NodeType macro defines fields, relation strings, and identity boilerplate in one place.
  - EMBEDDABLE_NODES/EMBEDDABLE_NODES_NOW prepared strings for common query forms.

High-Priority Issues (P0)
1) search_similar does not integrate HNSW search (index/hnsw.rs)
   - File: crates/ploke-db/src/index/hnsw.rs
   - Function: search_similar
   - Problem: The function constructs “base_script_start” and “base_script_end” for embedding retrieval, but never appends the HNSW clause (hnsw_script), unlike search_similar_args which does.
   - Impact: The function likely returns all embeddable nodes rather than top-k by vector similarity, defeating the primary purpose.
   - Fix: Append the HNSW segment (similar to search_similar_args) and add a test to verify returned rows shrink to k and contain “distance”.

2) Incorrect “or” clause emission in hnsw_all_types (index/hnsw.rs)
   - File: crates/ploke-db/src/index/hnsw.rs
   - Function: hnsw_all_types
   - Code: if !i > NodeType::primary_nodes().len() { script.push_str(" or "); }
   - Problem: !i is bitwise NOT on usize, yielding a very large number; the condition is almost always true.
   - Impact: The generated Cozo script likely includes a trailing "or" or malformed query.
   - Fix: Replace with if i + 1 < NodeType::primary_nodes().len() { ... } and add a unit test for generated script validity.

3) Fragile script construction in clear_relations and clear_hnsw_idx (database.rs)
   - File: crates/ploke-db/src/database.rs
   - Functions: clear_relations, clear_hnsw_idx
   - Problems:
     - clear_relations builds a list of relation names using DataValue::to_string() (which often includes quotes) then does script.extend(rels.split("\"")); This is brittle and can produce malformed ::remove statements.
     - clear_hnsw_idx similarly constructs ::index drop commands with script.extend(index.chars().filter(|c| *c == '\"')), which appends only quote characters, not the index name.
   - Impact: May silently fail to remove relations or indices, leaving the DB in an unexpected state. Hard to diagnose, easy to regress.
   - Fix: Parse names using DataValue::get_str() where possible, then join with proper quoting or Cozo’s expected syntax. Add tests to ensure relations/indices are actually removed.

4) CallbackManager Drop logic likely inverted (query/callbacks.rs)
   - File: crates/ploke-db/src/query/callbacks.rs
   - In Drop::drop, unregister_callback(*code).then(|| { tracing::error!("Failed to unregister ...") }).is_some()
   - Problem: bool::then executes closure when the bool is true. If unregister_callback returns true for success, the code logs an error on success.
   - Impact: Misleading logs and difficulty diagnosing genuine failures.
   - Fix: Invert the condition; log only when unregister returns false (or Result::is_err if it returns Result).

5) get_crate_name_id ignores its argument (database.rs)
   - File: crates/ploke-db/src/database.rs
   - Function: get_crate_name_id(&self, crate_name: &str)
   - Problem: The parameter crate_name is not used in the query; function reads the first crate_context row instead.
   - Impact: Returns non-deterministic or incorrect ID in multi-crate DBs.
   - Fix: Filter by name = $crate_name in the Cozo script and pass a parameter; add a test for at least two crates.

Medium-Priority Issues (P1)
6) QueryBuilder::insert_rhs_rel indexing logic is global, not per-type (query/builder.rs)
   - File: crates/ploke-db/src/query/builder.rs
   - Function: insert_rhs_rel
   - Problem: node_type_index is computed as max across all rhs_rels (all node types), not just the same node_type.
   - Impact: Incorrect indices for repeated relations (e.g., two *module {...} relations) breaking binding assumptions.
   - Fix: Filter keys by same node_type when computing next index.

7) Duplicated tokenizer implementations (bm25_index::CodeTokenizer vs index::tokenizer::CodeTokenizer)
   - Files:
     - crates/ploke-db/src/bm25_index/mod.rs (bm25_index::CodeTokenizer)
     - crates/ploke-db/src/index/tokenizer.rs (index::tokenizer::CodeTokenizer)
   - Problem: Divergent logic and behavior over time; tests only cover one side in detail.
   - Impact: Inconsistent tokenization between sparse and any future reuse; maintenance burden.
   - Fix: Consolidate to a single tokenizer module and re-export; add cross-tests to keep behavior stable.

8) CodeSnippet::from_db_row is placeholder and misleading (result/snippet.rs)
   - File: crates/ploke-db/src/result/snippet.rs
   - Function: CodeSnippet::from_db_row
   - Problem: Uses “name” as “text”; comments suggest expected row format but not enforced; file_path/span/context are defaulted.
   - Impact: Downstream users of into_snippets() will get non-snippet content and empty locations.
   - Fix: Either (a) adjust callers to pass actual snippet text/locs or (b) remove into_snippets path until query rows include snippet fields. Add tests.

9) Header-field coupling in QueryResult::to_embedding_nodes (result/mod.rs)
   - File: crates/ploke-db/src/result/mod.rs
   - Function: to_embedding_nodes
   - Problem: Hard-coded column names: file_path (string), file_hash (uuid), hash (uuid), span (slice). Any change in query heads breaks conversion.
   - Impact: Fragility across schema iterations or query tweaks.
   - Fix: Ensure all query producers align on these names; add a helper to validate headers and a single source-of-truth for the projection set (e.g., NodeType::embeddable_nodes_now).

10) to_usize assumes Num::Int (database.rs)
    - File: crates/ploke-db/src/database.rs
    - Function: to_usize
    - Problem: Only handles Num::Int; Cozo may return u64 or float for some queries. The error text also references i64 while using usize::try_from.
    - Impact: Unnecessary conversion failures if Cozo representation shifts.
    - Fix: Handle u64 and possibly floats that are whole (with bounds checks). Clarify the error messages.

11) String concatenation for scripts scattered and brittle
    - Files: multiple (database.rs, index/hnsw.rs, query/builder.rs)
    - Problem: Manual concatenation is error-prone and hard to test. Missing commas or braces cause runtime faults.
    - Impact: Frequent paper cuts and regressions.
    - Fix: Introduce small, reusable helpers (builders) to construct script blocks, or use format! with explicit placeholders and exhaustive tests for generated scripts.

12) Overuse of allow(dead_code) at module scope (query/builder.rs, span/tracker.rs, query/semantic.rs)
    - Keep allow(dead_code) to the minimum surface and revisit; these disable useful compiler checks.

13) Error mapping may downplay severity (error.rs)
    - File: crates/ploke-db/src/error.rs
    - impl From<DbError> for ploke_error::Error returns WarningError::PlokeDb
    - Problem: Converting all DbError into a warning may hide real failures.
    - Fix: Map selectively: severe DbError variants (Cozo, QueryExecution) -> Error; others -> Warning.

14) Span extraction and embedding logic are repeated variants
    - Functions like get_unembed_rel/get_embed_rel/get_rel_with_cursor share substantial boilerplate.
    - Consider centralizing ancestor rules and relation logic into a single parametrized function.

Opportunities (P2)
- Logging consistency:
  - There’s a mix of tracing::info/trace and eprintln! in tests; prefer tracing everywhere; eliminate eprintln!.
  - Use structured fields for ids and counts for better log filtering.
- API ergonomics:
  - Consider returning typed structs for queries (e.g., ordered results include distance) rather than bare QueryResult conversions sprinkled across file boundaries.
- Performance:
  - Build Cozo parameter maps with capacity pre-set where possible to avoid reallocation.
  - Avoid cloning strings when DataValue::get_str() yields &str; only allocate when promoting to owned strings.
- Documentation:
  - Many public functions are well documented; keep adding examples with no_run and edge cases.
  - Create developer-focused docs for “how we build Cozo scripts safely,” “conventions for headers/aliases,” and “how to add a new NodeType.”

Suggested Fixes by File (non-exhaustive but prioritized)
- crates/ploke-db/src/index/hnsw.rs
  - search_similar: append HNSW block; return only top-k; ensure headers include distance and that to_embedding_nodes keeps order if needed.
  - hnsw_all_types: fix “or” emission condition; add tests for script generation.
- crates/ploke-db/src/database.rs
  - clear_relations/clear_hnsw_idx: rework name extraction to avoid brittle to_string/split filtering; use get_str() and quote explicitly; add tests that create + drop sample relations/indices.
  - get_crate_name_id: filter by crate_name and use parameters.
  - to_usize: support u64 and clarify error messages.
- crates/ploke-db/src/query/builder.rs
  - insert_rhs_rel: compute index per-node-type.
  - with_name/add_lhs/lhs_to_query_string: consider parameterization (avoid string injection).
- crates/ploke-db/src/query/callbacks.rs
  - Drop::drop: fix inverted logging; assert or warn when unregister fails.
- crates/ploke-db/src/result/snippet.rs
  - Clarify row expectations; either return a richer snippet or remove into_snippets until the query provides snippet text/location.
- Tokenizer consolidation
  - Choose bm25_index::CodeTokenizer or index::tokenizer::CodeTokenizer as the single implementation and re-export; port tests.

Testing Gaps to Add
- Unit test for hnsw_all_types script assembly (ensures no trailing “or” and valid syntax).
- Integration test for search_similar: verify results length == k, include distance header, and ordering by distance.
- Tests for clear_relations and clear_hnsw_idx:
  - Add temp relations/indices, clear them, then assert absence.
- Test get_crate_name_id with two different crates to confirm filtering works.
- Test QueryBuilder::insert_rhs_rel with multiple same-type relations and verify distinct indices.

Security Considerations
- QueryBuilder.with_name uses format!("name = '{}'", name). This is vulnerable to Cozo script injection if name includes quotes or operators.
  - Switch to named parameters (e.g., name = $name) and put the variable in the parameter map.
- Any raw_query callers: prefer passing parameters to Cozo rather than interpolating data into scripts.

Maintainability and Consistency
- Prefer a single set of stable header names for embedding/projection across the crate. E.g., consistently use “file_hash” vs “tracking_hash” and settle on one alias for returned node hash (“hash” is currently used downstream).
- Centralize ancestor rules: ANCESTOR_RULES in Database exists, but some functions inline similar rules. Reuse the constant everywhere, and consider consolidating is_root_module as well.

Potential Refactors
- Introduce a tiny “CozoScriptBuilder” type that:
  - Holds a String and a params BTreeMap<String, DataValue>
  - Provides append_rule, append_relation, append_projection helpers
  - Has a method to run (immutable/mutable) via Database
- Unify EmbeddingData assembly:
  - Provide a single canonical query head macro/function for embeddable nodes and reuse it across functions that fetch embeddings.
- Provide a typed response for HNSW search:
  - e.g., struct SimilarResult { id: Uuid, name: String, distance: f64 }
  - A TryFrom<QueryResult> to enforce the header names from a single place

Nitpicks and Style
- Avoid commented-out large blocks in committed code; move alternatives to docs or behind feature flags if needed.
- Use consistent import ordering and keep dbg/tracing statements consistent (prefer tracing; remove println!/eprintln!).
- Consider narrowing dead_code allowances and allow(unused_imports) only within test modules or behind test cfgs.

Questions / Clarifications
- Should Import and Impl be considered “primary” nodes for embedding? They are excluded in primary_nodes() but exist in define_static_fields!. If this is by design, document the rationale in NodeType::primary_nodes.
- What is the invariant for Cozo schema versioning? It might be useful to store a schema version row and have helpers that verify it on Database::init_with_schema to avoid drift between ploke-transform and ploke-db.

Immediate Action Plan (ordered)
- P0 fixes:
  1. Fix search_similar to append HNSW block and return top-k by distance; add tests.
  2. Correct hnsw_all_types “or” condition and add a unit test.
  3. Rewrite clear_relations and clear_hnsw_idx string assembly; test with example relations/indices.
  4. Fix CallbackManager Drop logging inversion.
  5. Make get_crate_name_id use crate_name parameter; add tests.
- P1:
  6. Fix QueryBuilder::insert_rhs_rel per-type indexing; add tests.
  7. Consolidate tokenizers; port tests; remove duplication.
  8. Clarify CodeSnippet::from_db_row semantics; adjust callers or postpone feature.
  9. Harden to_usize and header coupling.
- P2:
  10. Centralize rule strings and script generation helpers.
  11. Improve parameterization to remove ad-hoc string formatting.

Acknowledgements
- The crate exhibits strong intent toward maintainable, testable database code and indexing subsystems.
- The use of Cozo “NOW” snapshots and well-typed EmbeddingData present a good foundation for incremental updates and reproducibility.
- With a pass on the highlighted P0/P1 items, the system will be significantly more robust and easier to extend.
