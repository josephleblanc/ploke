//! Proptest schedule fuzzing for command dispatch concurrency.
//!
//! Covered (exactly):
//! - Real `state_manager` async actor loop.
//! - Command schedule generated by proptest:
//!   - 1..N commands per case (schedule length, N varies by test).
//!   - 4 worker buckets; each command assigned to one worker.
//!   - `TestCommand` variants:
//!     - `AddImmediate` / `AddUser` / `Update` / `Delete`
//!     - `Navigate` (Up/Down/Top/Bottom)
//!     - `SetPreview` (CodeBlock/Diff)
//!     - `SetMaxPreviewLines` (1..599)
//!     - `SetAutoConfirm` (bool)
//! - External service path:
//!   - One `EmbedMessage` command per case (uses mock RAG + pre-resolved oneshots).
//! - Command parsing:
//!   - Parses a bounded set of command strings (edit preview/lines/auto).
//!   - Applies parsed edit commands by translating to `StateCommand`s.
//! - UI rendering:
//!   - Renders one frame of `ConversationView` + `InputView` using `TestBackend`.
//! - Input domains:
//!   - `content`: arbitrary Unicode strings of length 0..60.
//!   - `status`: None | Pending | Generating | Completed | Error(description 0..40 chars).
//!   - IDs: arbitrary 16-byte values mapped to `Uuid`.
//! - Interleavings: each worker yields after every send.
//! - Assertions:
//!   - Test completes without panic/deadlock.
//!   - `chat.current` and `chat.tail` both exist in `chat.messages` at end.
//! - Two runtimes:
//!   - `command_schedule_proptest_quick` is the default, quick-running version.
//!   - `command_schedule_proptest_long` is ignored by default for nightly/weekly runs.
//!
//! Not covered:
//! - Commands beyond the `TestCommand` set.
//! - Strong invariants beyond message ID existence (e.g., navigation correctness).
//! - Exhaustive scheduling (proptest explores many schedules but is not exhaustive).
//! - Real external services (LLM network calls, filesystem indexing). Embed flow uses mock RAG.
//! - Profiling is coarse (total run time only) and opt-in via env var.
use std::sync::Arc;
use std::time::Instant;

use ploke_tui::EventBusCaps;
use ploke_tui::app_state::commands::{ListNavigation, StateCommand};
use ploke_tui::app_state::core::PreviewMode;
use ploke_tui::app_state::state_manager;
use ploke_tui::chat_history::{MessageKind, MessageStatus, MessageUpdate};
use ploke_tui::app::commands::parser;
use ploke_tui::app::commands::parser::Command;
use ploke_tui::test_utils::mock;
use ploke_tui::app::view::components::conversation::ConversationView;
use ploke_tui::app::view::components::input_box::InputView;
use ploke_tui::chat_history::{ContextStatus, Message};
use ploke_tui::ui_theme::UiTheme;
use ploke_tui::user_config::CommandStyle;
use ploke_tui::{EventBus, RagEvent};
use proptest::prelude::*;
use proptest::test_runner::{TestCaseError, TestRunner};
use ratatui::backend::TestBackend;
use ratatui::Terminal;
use std::collections::HashMap;
use tokio::sync::{mpsc, oneshot};
use tokio::time::{Duration, sleep};
use uuid::Uuid;

const WORKERS: usize = 4;
const QUICK_CASES: u32 = 4;
const QUICK_MAX_COMMANDS: usize = 30;
const LONG_CASES: u32 = 256;
const LONG_MAX_COMMANDS: usize = 120;

#[derive(Clone, Debug)]
enum TestCommand {
    AddImmediate { id: [u8; 16], content: String },
    AddUser { id: [u8; 16], content: String },
    Update { id: [u8; 16], content: String, status: Option<MessageStatus> },
    Delete { id: [u8; 16] },
    Navigate { dir: ListNavigation },
    SetPreview { mode: PreviewMode },
    SetMaxPreviewLines { lines: usize },
    SetAutoConfirm { enabled: bool },
}

impl TestCommand {
    fn to_state_command(self) -> StateCommand {
        match self {
            TestCommand::AddImmediate { id, content } => StateCommand::AddMessageImmediate {
                msg: content,
                kind: MessageKind::SysInfo,
                new_msg_id: Uuid::from_bytes(id),
            },
            TestCommand::AddUser { id, content } => {
                let (tx, _rx) = oneshot::channel();
                StateCommand::AddUserMessage {
                    content,
                    new_user_msg_id: Uuid::from_bytes(id),
                    completion_tx: tx,
                }
            }
            TestCommand::Update { id, content, status } => StateCommand::UpdateMessage {
                id: Uuid::from_bytes(id),
                update: MessageUpdate {
                    content: Some(content),
                    append_content: None,
                    status,
                    metadata: None,
                },
            },
            TestCommand::Delete { id } => StateCommand::DeleteMessage {
                id: Uuid::from_bytes(id),
            },
            TestCommand::Navigate { dir } => StateCommand::NavigateList { direction: dir },
            TestCommand::SetPreview { mode } => StateCommand::SetEditingPreviewMode { mode },
            TestCommand::SetMaxPreviewLines { lines } => {
                StateCommand::SetEditingMaxPreviewLines { lines }
            }
            TestCommand::SetAutoConfirm { enabled } => StateCommand::SetEditingAutoConfirm { enabled },
        }
    }
}

fn any_string(max: usize) -> impl Strategy<Value = String> {
    proptest::collection::vec(any::<char>(), 0..max).prop_map(|chars| chars.into_iter().collect())
}

fn status_strategy() -> impl Strategy<Value = Option<MessageStatus>> {
    prop_oneof![
        Just(None),
        Just(Some(MessageStatus::Pending)),
        Just(Some(MessageStatus::Generating)),
        Just(Some(MessageStatus::Completed)),
        any_string(40).prop_map(|description| Some(MessageStatus::Error { description })),
    ]
}

fn command_strategy() -> impl Strategy<Value = TestCommand> {
    prop_oneof![
        (any::<[u8; 16]>(), any_string(60)).prop_map(|(id, content)| TestCommand::AddImmediate { id, content }),
        (any::<[u8; 16]>(), any_string(60)).prop_map(|(id, content)| TestCommand::AddUser { id, content }),
        (any::<[u8; 16]>(), any_string(60), status_strategy())
            .prop_map(|(id, content, status)| TestCommand::Update { id, content, status }),
        any::<[u8; 16]>().prop_map(|id| TestCommand::Delete { id }),
        prop_oneof![
            Just(ListNavigation::Up),
            Just(ListNavigation::Down),
            Just(ListNavigation::Top),
            Just(ListNavigation::Bottom),
        ]
        .prop_map(|dir| TestCommand::Navigate { dir }),
        prop_oneof![
            Just(PreviewMode::CodeBlock),
            Just(PreviewMode::Diff),
        ]
        .prop_map(|mode| TestCommand::SetPreview { mode }),
        (1usize..600usize).prop_map(|lines| TestCommand::SetMaxPreviewLines { lines }),
        any::<bool>().prop_map(|enabled| TestCommand::SetAutoConfirm { enabled }),
    ]
}

fn schedule_strategy_with(max_commands: usize) -> impl Strategy<Value = Vec<(usize, TestCommand)>> {
    proptest::collection::vec(
        (0usize..WORKERS, command_strategy()),
        1..(max_commands + 1),
    )
}

fn command_input_strategy() -> impl Strategy<Value = Vec<String>> {
    let preview = prop_oneof![
        Just("/edit preview mode diff".to_string()),
        Just("/edit preview mode code".to_string()),
        Just("/edit preview mode codeblock".to_string()),
    ];
    let lines = (1usize..200usize).prop_map(|n| format!("/edit preview lines {}", n));
    let auto = prop_oneof![
        Just("/edit auto on".to_string()),
        Just("/edit auto off".to_string()),
        Just("/edit auto true".to_string()),
        Just("/edit auto false".to_string()),
    ];
    proptest::collection::vec(prop_oneof![preview, lines, auto], 0..12)
}

fn run_case(
    schedule: Vec<(usize, TestCommand)>,
    inputs: Vec<String>,
) -> Result<(), TestCaseError> {
    let rt = tokio::runtime::Builder::new_multi_thread()
        .worker_threads(2)
        .enable_all()
        .build()
        .expect("runtime");
    rt.block_on(async {
        let state = Arc::new(mock::create_mock_app_state());
        let (cmd_tx, cmd_rx) = mpsc::channel(128);
        let event_bus = Arc::new(EventBus::new(EventBusCaps::default()));
        let (rag_tx, _rag_rx) = mpsc::channel::<RagEvent>(16);

        tokio::spawn(state_manager(
            state.clone(),
            cmd_rx,
            event_bus.clone(),
            rag_tx,
        ));

        for input in inputs {
            let cmd = parser::parse(&mock::create_mock_app(), &input, CommandStyle::Slash);
            match cmd {
                Command::EditSetPreviewMode(mode) => {
                    let _ = cmd_tx
                        .send(StateCommand::SetEditingPreviewMode { mode })
                        .await;
                }
                Command::EditSetPreviewLines(lines) => {
                    let _ = cmd_tx
                        .send(StateCommand::SetEditingMaxPreviewLines { lines })
                        .await;
                }
                Command::EditSetAutoConfirm(enabled) => {
                    let _ = cmd_tx
                        .send(StateCommand::SetEditingAutoConfirm { enabled })
                        .await;
                }
                _ => {}
            }
        }

        let (seed_tx, _seed_rx) = oneshot::channel();
        let _ = cmd_tx
            .send(StateCommand::AddUserMessage {
                content: "seed user message".to_string(),
                new_user_msg_id: Uuid::new_v4(),
                completion_tx: seed_tx,
            })
            .await;

        let (completion_tx, completion_rx) = oneshot::channel();
        let (scan_tx, scan_rx) = oneshot::channel();
        let _ = completion_tx.send(());
        let _ = scan_tx.send(None);
        let _ = cmd_tx
            .send(StateCommand::EmbedMessage {
                new_msg_id: Uuid::new_v4(),
                completion_rx,
                scan_rx,
            })
            .await;

        let mut buckets: Vec<Vec<TestCommand>> = vec![Vec::new(); WORKERS];
        for (worker, cmd) in schedule {
            buckets[worker].push(cmd);
        }

        let mut handles = Vec::with_capacity(WORKERS);
        for cmds in buckets {
            let cmd_tx = cmd_tx.clone();
            handles.push(tokio::spawn(async move {
                for cmd in cmds {
                    let state_cmd = cmd.to_state_command();
                    let _ = cmd_tx.send(state_cmd).await;
                    tokio::task::yield_now().await;
                }
            }));
        }

        for handle in handles {
            let _ = handle.await;
        }

        let backend = TestBackend::new(80, 24);
        let mut terminal = Terminal::new(backend).expect("terminal");
        let mut convo = ConversationView::default();
        let mut input_view = InputView::default();
        let theme = UiTheme::default();
        let msg = Message {
            id: Uuid::new_v4(),
            status: MessageStatus::Completed,
            metadata: None,
            parent: None,
            children: Vec::new(),
            selected_child: None,
            kind: MessageKind::User,
            content: "render seed".to_string(),
            tool_call_id: None,
            tool_payload: None,
            context_status: ContextStatus::default(),
        };
        let messages = vec![msg];
        convo.prepare(
            messages.iter(),
            messages.len(),
            80,
            20,
            Some(0),
            ploke_tui::tools::ToolVerbosity::Normal,
        );
        terminal
            .draw(|frame| {
                let area = frame.area();
                convo.render(
                    frame,
                    messages.iter(),
                    area.width,
                    area,
                    Some(0),
                    ploke_tui::tools::ToolVerbosity::Normal,
                    &HashMap::new(),
                );
                input_view.render(
                    frame,
                    area,
                    "render input",
                    ploke_tui::app::types::Mode::Insert,
                    &theme,
                    None,
                    &[],
                    None,
                );
            })
            .expect("render");

        drop(cmd_tx);
        sleep(Duration::from_millis(50)).await;

        let chat = state.chat.0.read().await;
        prop_assert!(chat.messages.contains_key(&chat.current));
        prop_assert!(chat.messages.contains_key(&chat.tail));
        Ok(())
    })
}

fn run_proptest(cases: u32, max_commands: usize, label: &str) {
    let config = ProptestConfig {
        cases,
        ..ProptestConfig::default()
    };
    let mut runner = TestRunner::new(config);
    let strat = (
        schedule_strategy_with(max_commands),
        command_input_strategy(),
    );
    let start = Instant::now();
    let result = runner.run(&strat, |(schedule, inputs)| run_case(schedule, inputs));
    if std::env::var("PLOKE_PROPTEST_PROFILE").is_ok() {
        let elapsed = start.elapsed();
        eprintln!(
            "[proptest-profile] {}: cases={} max_commands={} elapsed={:?}",
            label, cases, max_commands, elapsed
        );
    }
    if let Err(err) = result {
        panic!("{}", err);
    }
}

#[test]
fn command_schedule_proptest_quick() {
    run_proptest(QUICK_CASES, QUICK_MAX_COMMANDS, "quick");
}

#[test]
#[ignore]
fn command_schedule_proptest_long() {
    run_proptest(LONG_CASES, LONG_MAX_COMMANDS, "long");
}
