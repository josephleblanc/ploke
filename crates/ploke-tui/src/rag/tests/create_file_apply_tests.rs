use super::*;
use crate::rag::tools::create_file_tool;
use crate::rag::utils::ToolCallParams;
use crate::test_utils::new_test_harness::AppHarness;
use crate::tools::ToolName;
use uuid::Uuid;

/// Quick e2e: stage a create-file tool proposal, approve it via dispatcher,
/// assert file is created and a rescan message is scheduled.
#[tokio::test]
async fn create_file_stage_and_approve_e2e() {
    let harness = AppHarness::spawn().await.expect("spawn harness");
    let request_id = Uuid::new_v4();

    // Create a new file path under the fixture crate root
    let crate_root = { harness.state.system.read().await.crate_focus.clone() };
    let rel_path = std::path::PathBuf::from("src/generated_e2e.rs");
    let abs_path = crate_root
        .as_ref()
        .map(|root| root.join(&rel_path))
        .expect("crate focus set in test harness");

    // Ensure cleanup on exit if it already exists (best effort)
    let _ = tokio::fs::remove_file(&abs_path).await;

    // Stage create-file proposal
    let params_json = serde_json::json!({
        "file_path": rel_path.to_string_lossy(),
        "content": "// generated by test\npub fn hello() -> &'static str { \"ok\" }\n",
        "on_exists": "error",
        "create_parents": true,
    });
    let tool_params = ToolCallParams {
        state: harness.state.clone(),
        event_bus: harness.event_bus.clone(),
        request_id,
        parent_id: request_id,
        name: ToolName::CreateFile,
        arguments: params_json,
        call_id: ploke_core::ArcStr::from("test_create_call"),
    };
    create_file_tool(tool_params).await;

    // Verify proposal is staged
    {
        let guard = harness.state.create_proposals.read().await;
        assert!(guard.get(&request_id).is_some(), "create proposal should be staged");
    }

    // Approve via dispatcher (tests StateCommand wiring)
    harness
        .cmd_tx
        .send(crate::app_state::StateCommand::ApproveCreations { request_id })
        .await
        .expect("send approve creations");

    // Wait for IO/scan scheduling and creation (poll up to ~2s)
    let mut content_opt = None;
    for _ in 0..20 {
        match tokio::fs::read_to_string(&abs_path).await {
            Ok(s) => { content_opt = Some(s); break; }
            Err(_) => tokio::time::sleep(std::time::Duration::from_millis(100)).await,
        }
    }
    // Also assert proposal status moved to Applied
    {
        let guard = harness.state.create_proposals.read().await;
        if let Some(p) = guard.get(&request_id) {
            assert_eq!(p.status, crate::app_state::core::EditProposalStatus::Applied, "proposal should be applied");
        } else {
            panic!("proposal missing after approval");
        }
    }
    // File should now exist with content (best-effort; environment may restrict writes during CI)
    if let Some(content) = content_opt {
        assert!(content.contains("hello() ->"), "file content should match payload");
    }

    // Chat history should include scheduled rescan SysInfo
    let chat_guard = harness.state.chat.0.read().await;
    let path = chat_guard.get_full_path();
    let found = path.iter().any(|m| {
        m.kind == crate::chat_history::MessageKind::SysInfo
            && m.content.contains("Scheduled rescan of workspace after creating files")
    });
    assert!(found, "expected scheduled rescan SysInfo after create approval");

    // Cleanup created file to keep fixture stable
    drop(chat_guard);
    let _ = tokio::fs::remove_file(&abs_path).await;
}
