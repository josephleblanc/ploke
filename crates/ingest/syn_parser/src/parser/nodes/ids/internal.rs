//! Private implementation module for strictly encapsulated typed node identifiers.
//!
//! Defines the ID newtype structs with private fields, implements necessary traits
//! internally, provides restricted constructors, and defines helper types like
//! `AnyNodeId`. Access to the base `NodeId` is confined to this module.

// We will move ID definitions, trait implementations, etc., here later.
use super::*;
use std::borrow::Borrow;
use std::fmt::Display;

// Example structure (will be generated by macro later)
// #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
// pub struct ExampleNodeId(NodeId);
//
// impl ExampleNodeId {
//     // Constructor restricted to crate::parser::nodes module
//     pub(in crate::parser::nodes) fn create(id: NodeId) -> Self { Self(id) }
//     // Internal access to base ID
//     pub(super) fn base_id(&self) -> NodeId { self.0 }
// }
// // Manual trait impls needed because field is private
// // Display can delegate publicly if needed via re-export
// impl fmt::Display for ExampleNodeId { fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "{}", self.0) } }
// // Borrow/AsRef might need internal impl if base ID access is restricted
// impl Borrow<NodeId> for ExampleNodeId { fn borrow(&self) -> &NodeId { &self.0 } }
// impl AsRef<NodeId> for ExampleNodeId { fn as_ref(&self) -> &NodeId { &self.0 } }

// Define AnyNodeId enum here later
// Define marker traits (TypedId, PrimaryNodeIdTrait, etc.) here later
// Define TypedNodeIdGet trait here later
// Define private sealing trait here later

// ----- Traits -----

/// Allows retrieving the corresponding `GraphNode` trait object from a graph
/// using a specific typed ID.
///
/// This trait is implemented internally for each specific ID type that represents
/// a node directly stored and retrievable in the `GraphAccess` implementor.
pub(crate) trait TypedNodeIdGet: Copy + private_traits::Sealed {
    // Added Copy bound as IDs are Copy
    // Added Sealed bound to prevent external implementations
    fn get<'g>(&self, graph: &'g dyn GraphAccess) -> Option<&'g dyn GraphNode>;
}

// ----- Macros -----

/// Macro to generate category enums (like PrimaryNodeId, AnyNodeId) that wrap specific typed IDs.
///
/// Generates:
/// - The enum definition with specified variants.
/// - Standard derives: Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord.
/// - `impl EnumName`:
///   - `pub fn base_id(&self) -> NodeId`: Calls `base_id()` on the inner typed ID.
///   - `pub fn kind(&self) -> ItemKind` (optional): Returns the corresponding `ItemKind`.
/// - `impl From<SpecificIdType> for EnumName` for each variant.
///
/// # Usage
/// ```ignore
/// define_category_enum!(
///     #[doc = "Represents primary node IDs."] // Optional outer attributes
///     PrimaryNodeId, // Enum Name
///     ItemKind, // Include kind() method that returns this type
///     [ // List of variants: (VariantName, SpecificIdType, ItemKindValue)
///         (Function, FunctionNodeId, ItemKind::Function),
///         (Struct, StructNodeId, ItemKind::Struct),
///         // ...
///     ]
/// );
///
/// define_category_enum!(
///     AnyNodeId, // Enum Name
///     // No ItemKind specified, so kind() method won't be generated
///     [ // List of variants: (VariantName, SpecificIdType)
///         (Function, FunctionNodeId),
///         (Struct, StructNodeId),
///         // ... *all* specific IDs
///     ]
/// );
/// ```
macro_rules! define_category_enum {
    // Matcher for enums WITH an associated ItemKind method
    ($(#[$outer:meta])* $EnumName:ident, $KindType:ty, [ $( ($Variant:ident, $IdType:ty, $ItemKindVal:expr) ),* $(,)? ] ) => {
        $(#[$outer])*
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub enum $EnumName {
            $(
                $Variant($IdType),
            )*
        }

        impl $EnumName {
            /// Returns the underlying base NodeId using the internal `base_id` method
            /// of the wrapped specific ID type.
            #[inline]
            pub fn base_id(&self) -> NodeId {
                match *self {
                    $(
                        $EnumName::$Variant(id) => id.base_id(),
                    )*
                }
            }

            /// Returns the corresponding ItemKind for this category ID variant.
            #[inline]
            pub fn kind(&self) -> $KindType {
                match *self {
                    $(
                        $EnumName::$Variant(_) => $ItemKindVal,
                    )*
                }
            }
        }

        $(
            impl From<$IdType> for $EnumName {
                #[inline]
                fn from(id: $IdType) -> Self {
                    $EnumName::$Variant(id)
                }
            }
        )*
    };

    // Matcher for enums WITHOUT an associated ItemKind method (like AnyNodeId)
    ($(#[$outer:meta])* $EnumName:ident, [ $( ($Variant:ident, $IdType:ty) ),* $(,)? ] ) => {
        $(#[$outer])*
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub enum $EnumName {
            $(
                $Variant($IdType),
            )*
        }

        impl $EnumName {
            /// Returns the underlying base NodeId using the internal `base_id` method
            /// of the wrapped specific ID type.
            #[inline]
            pub fn base_id(&self) -> NodeId {
                match *self {
                    $(
                        $EnumName::$Variant(id) => id.base_id(),
                    )*
                }
            }
            // No kind() method generated for this variant
        }

        $(
            impl From<$IdType> for $EnumName {
                #[inline]
                fn from(id: $IdType) -> Self {
                    $EnumName::$Variant(id)
                }
            }
        )*
    };
}

/// Macro to implement the `TypedNodeIdGet` trait for a specific ID type.
///
/// # Usage
/// ```ignore
/// // Implements TypedNodeIdGet for StructNodeId using graph.get_struct()
/// impl_typed_node_id_get!(StructNodeId, get_struct);
/// ```
macro_rules! impl_typed_node_id_get {
    ($IdType:ty, $GetterMethod:ident) => {
        // Implement the private sealing trait first
        impl private_traits::Sealed for $IdType {}
        // Implement the getter trait
        impl TypedNodeIdGet for $IdType {
            #[inline]
            fn get<'g>(&self, graph: &'g dyn GraphAccess) -> Option<&'g dyn GraphNode> {
                // Call the specified getter method on GraphAccess (e.g., graph.get_struct(*self))
                // and cast the result to &dyn GraphNode.
                graph
                    .$GetterMethod(*self)
                    .map(|node| node as &dyn GraphNode)
            }
        }
    };
}

// ----- Internal Macro for Typed IDs -----

/// Macro to define a strictly encapsulated newtype wrapper around NodeId.
///
/// Generates:
/// - A public struct `StructName(NodeId)` where the `NodeId` field is private.
/// - Derives: Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord.
/// - `impl StructName`:
///   - `pub(in crate::parser::nodes) fn create(NodeId) -> Self`: Restricted constructor.
///   - `pub(super) fn base_id(&self) -> NodeId`: Internal access to the base ID.
/// - `impl Display for StructName` (delegates to inner NodeId).
/// - `impl Borrow<NodeId>` and `impl AsRef<NodeId>` for internal use if needed (though direct access via `base_id` might be preferred).
///
/// # Usage (within this module)
/// ```ignore
/// define_internal_node_id!(
///     #[doc = "Identifier for a function node."] // Optional outer attributes
///     FunctionNodeId
/// );
/// ```
macro_rules! define_internal_node_id {
    ($(#[$outer:meta])* $NewTypeId:ident) => {
        $(#[$outer])*
        // The struct is pub, but its field NodeId is private by default
        // because NodeId itself is not pub in this scope after potential future refactoring
        // or simply because tuple struct fields are private without `pub`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub struct $NewTypeId(NodeId);

        impl $NewTypeId {
            /// Creates a new typed ID. Restricted constructor.
            /// Only code within `crate::parser::nodes` can call this.
            /// Ensures typed IDs are only created alongside actual node construction.
            #[inline]
            pub(in crate::parser::nodes) fn create(id: NodeId) -> Self {
                Self(id)
            }

            /// Get the underlying base NodeId.
            /// Restricted visibility (`pub(super)`) allows access only within the `ids` module.
            /// This is the controlled escape hatch for internal operations like hashing,
            /// indexing in generic maps, or passing context to ploke-core.
            #[inline]
            pub(super) fn base_id(&self) -> NodeId {
                self.0
            }

            // We intentionally DO NOT provide public or pub(crate) `into_inner` or `as_inner`.
            // Access to the base ID outside this module should be impossible.
        }

        impl std::fmt::Display for $NewTypeId {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                // Delegate to the inner NodeId's Display implementation
                write!(f, "{}", self.0)
            }
        }

        // These Borrow/AsRef impls might be useful for internal generic code
        // within the `ids` module that needs to operate on the base ID without
        // consuming the wrapper. However, calling `base_id()` might be clearer.
        // Keep them commented out unless a clear need arises.
        // impl std::borrow::Borrow<NodeId> for $NewTypeId {
        //     #[inline]
        //     fn borrow(&self) -> &NodeId {
        //         &self.0
        //     }
        // }
        //
        // impl AsRef<NodeId> for $NewTypeId {
        //     #[inline]
        //     fn as_ref(&self) -> &NodeId {
        //         &self.0
        //     }
        // }

        // Placeholder for implementing marker traits via the macro later
        // impl $crate::parser::nodes::ids::internal::TypedId for $NewTypeId {}
        // // Example: Add marker trait implementation based on macro input
        // // define_internal_node_id!(StructNodeId, marker: PrimaryNodeIdTrait);
        // // macro_rules! define_internal_node_id {
        // //     ($NewTypeId:ident $(, marker: $MarkerTrait:path)*) => { ... $(impl $MarkerTrait for $NewTypeId {})* ... }
        // // }
    };
}

// Now use the *new* internal macro
define_internal_node_id!(EnumNodeId);
define_internal_node_id!(FunctionNodeId); // For standalone functions
define_internal_node_id!(MethodNodeId); // For associated functions/methods
define_internal_node_id!(ImplNodeId);
define_internal_node_id!(ImportNodeId);
define_internal_node_id!(ModuleNodeId); // Use the macro now, assuming no special manual impl needed yet
define_internal_node_id!(StructNodeId);
define_internal_node_id!(TraitNodeId);
define_internal_node_id!(TypeAliasNodeId);
define_internal_node_id!(UnionNodeId);
// Removed ValueNodeId
define_internal_node_id!(ConstNodeId); // Added
define_internal_node_id!(StaticNodeId); // Added
define_internal_node_id!(FieldNodeId);
define_internal_node_id!(VariantNodeId);
define_internal_node_id!(ParamNodeId); // For ParamData
define_internal_node_id!(GenericParamNodeId);
define_internal_node_id!(MacroNodeId);

// For more explicit differntiation within Phase 3 module tree processing
define_internal_node_id!(ReexportNodeId);
// --- Category ID Enums ---

use ploke_core::ItemKind; // Need ItemKind for kind() methods

pub trait PrimaryNodeMarker {}

impl PrimaryNodeMarker for FunctionNode {}
impl PrimaryNodeMarker for StructNode {}
impl PrimaryNodeMarker for UnionNode {}
impl PrimaryNodeMarker for EnumNode {}
impl PrimaryNodeMarker for TypeAliasNode {}
impl PrimaryNodeMarker for TraitNode {}
impl PrimaryNodeMarker for ImplNode {}
impl PrimaryNodeMarker for ConstNode {}
impl PrimaryNodeMarker for StaticNode {}
impl PrimaryNodeMarker for MacroNode {}
impl PrimaryNodeMarker for ImportNode {}
impl PrimaryNodeMarker for ModuleNode {}

// --- Marker Traits ---
// Define the marker traits themselves here. Implementations will be added later,
// ideally via the define_internal_node_id! macro.
pub trait TypedId: Copy + std::fmt::Debug + std::hash::Hash + Eq + Ord {} // Base trait for all typed IDs
pub trait PrimaryNodeIdTrait: TypedId {} // Marker for primary node IDs
pub trait AssociatedItemIdTrait: TypedId {} // Marker for associated item IDs
pub trait SecondaryNodeIdTrait: TypedId {} // Marker for secondary node IDs (fields, params, etc.)

// Add other category marker traits as needed

/// Private module for the sealing pattern. Prevents external crates or modules                    
/// from implementing traits intended only for internal ID types (like TypedNodeIdGet).            
mod private_traits {
    /// The sealing trait. Cannot be named or implemented outside this module.                     
    pub(super) trait Sealed {}
}
// --- TypedNodeIdGet Implementations ---
// Primary Nodes
impl_typed_node_id_get!(FunctionNodeId, get_function);
impl_typed_node_id_get!(StructNodeId, get_struct);
impl_typed_node_id_get!(EnumNodeId, get_enum);
impl_typed_node_id_get!(UnionNodeId, get_union);
impl_typed_node_id_get!(TypeAliasNodeId, get_type_alias);
impl_typed_node_id_get!(TraitNodeId, get_trait);
impl_typed_node_id_get!(ImplNodeId, get_impl);
impl_typed_node_id_get!(ConstNodeId, get_const);
impl_typed_node_id_get!(StaticNodeId, get_static);
impl_typed_node_id_get!(MacroNodeId, get_macro);
impl_typed_node_id_get!(ImportNodeId, get_import);
impl_typed_node_id_get!(ModuleNodeId, get_module);

// Associated Items (Methods are retrieved via their parent Impl/Trait, not directly)
// Note: MethodNodeId does *not* get an impl, as there's no `graph.get_method(MethodNodeId)`

// Secondary Nodes (Fields, Variants, Params, Generics are part of their parent node, not directly retrieved)
// Note: FieldNodeId, VariantNodeId, ParamNodeId, GenericParamNodeId do *not* get impls.

// Other IDs
// Note: ReexportNodeId does *not* get an impl.

// --- Generated Category Enums ---

define_category_enum!(
    #[doc = "Represents the ID of any node type that can typically be defined directly within a module scope (primary items)."]
    PrimaryNodeId,
    ItemKind,
    [
        (Function, FunctionNodeId, ItemKind::Function),
        (Struct, StructNodeId, ItemKind::Struct),
        (Enum, EnumNodeId, ItemKind::Enum),
        (Union, UnionNodeId, ItemKind::Union),
        (TypeAlias, TypeAliasNodeId, ItemKind::TypeAlias),
        (Trait, TraitNodeId, ItemKind::Trait),
        (Impl, ImplNodeId, ItemKind::Impl),
        (Const, ConstNodeId, ItemKind::Const),
        (Static, StaticNodeId, ItemKind::Static),
        (Macro, MacroNodeId, ItemKind::Macro),
        (Import, ImportNodeId, ItemKind::Import),
        (Module, ModuleNodeId, ItemKind::Module),
    ]
);

define_category_enum!(
    #[doc = "Represents the ID of any node type that can be an associated item within an `impl` or `trait` block."]
    AssociatedItemId,
    ItemKind,
    [
        (Method, MethodNodeId, ItemKind::Method),
        (TypeAlias, TypeAliasNodeId, ItemKind::TypeAlias), // Associated types use TypeAliasNodeId
        (Const, ConstNodeId, ItemKind::Const),             // Associated consts use ConstNodeId
    ]
);

// Define AnyNodeId to hold *all* specific node ID types.
// This serves as the primary key for heterogeneous storage like HashMaps.
define_category_enum!(
    #[doc = "Represents the ID of *any* node type in the graph. Used as a key for heterogeneous storage."]
    AnyNodeId,
    // Use the macro arm that does *not* expect ItemKind
    [
        // Primary Nodes
        (Function, FunctionNodeId),
        (Struct, StructNodeId),
        (Enum, EnumNodeId),
        (Union, UnionNodeId),
        (TypeAlias, TypeAliasNodeId),
        (Trait, TraitNodeId),
        (Impl, ImplNodeId),
        (Const, ConstNodeId),
        (Static, StaticNodeId),
        (Macro, MacroNodeId),
        (Import, ImportNodeId),
        (Module, ModuleNodeId),
        // Associated Items (using their specific IDs)
        (Method, MethodNodeId),
        // Secondary Nodes
        (Field, FieldNodeId),
        (Variant, VariantNodeId),
        (Param, ParamNodeId),
        (GenericParam, GenericParamNodeId),
        // Other IDs
        (Reexport, ReexportNodeId),
        // Add any other specific ID types here as they are created
    ]
);

// --- Node Struct Definitions ---
// Logging target
const LOG_TARGET_NODE: &str = "node_info"; // Define log target for visibility checks

// end up needing access to NodeId
/// Core trait for all graph nodes
pub trait GraphNode {
    fn id(&self) -> NodeId;
    fn visibility(&self) -> &VisibilityKind;
    fn name(&self) -> &str;
    fn cfgs(&self) -> &[String];

    // --- Default implementations for downcasting ---
    fn as_function(&self) -> Option<&FunctionNode> {
        // Standalone function
        None
    }
    fn as_method(&self) -> Option<&MethodNode> {
        // Associated function/method
        None
    }
    fn as_struct(&self) -> Option<&StructNode> {
        None
    }
    fn as_enum(&self) -> Option<&EnumNode> {
        None
    }
    fn as_union(&self) -> Option<&UnionNode> {
        None
    }
    fn as_type_alias(&self) -> Option<&TypeAliasNode> {
        None
    }
    fn as_trait(&self) -> Option<&TraitNode> {
        None
    }
    fn as_impl(&self) -> Option<&ImplNode> {
        None
    }
    fn as_module(&self) -> Option<&ModuleNode> {
        None
    }
    fn as_const(&self) -> Option<&ConstNode> {
        // Added
        None
    }
    fn as_static(&self) -> Option<&StaticNode> {
        // Added
        None
    }
    fn as_macro(&self) -> Option<&MacroNode> {
        None
    }
    fn as_import(&self) -> Option<&ImportNode> {
        None
    }
    fn kind_matches(&self, kind: ItemKind) -> bool {
        match kind {
            ItemKind::Function => self.as_function().is_some(), // Matches standalone functions
            ItemKind::Method => self.as_method().is_some(), // Matches associated functions/methods
            ItemKind::Struct => self.as_struct().is_some(),
            ItemKind::Enum => self.as_enum().is_some(),
            ItemKind::Union => self.as_union().is_some(),
            ItemKind::TypeAlias => self.as_type_alias().is_some(),
            ItemKind::Trait => self.as_trait().is_some(),
            ItemKind::Impl => self.as_impl().is_some(),
            ItemKind::Module => self.as_module().is_some(),
            ItemKind::Const => self.as_const().is_some(), // Updated
            ItemKind::Static => self.as_static().is_some(), // Updated
            ItemKind::Macro => self.as_macro().is_some(),
            ItemKind::Import => self.as_import().is_some(),
            ItemKind::ExternCrate => {
                // kind of a hack job. needs cleaner solution
                if let Some(import_node) = self.as_import() {
                    // Use if let for safety
                    import_node.is_extern_crate()
                } else {
                    false
                }
            }

            // ItemKind::Field | ItemKind::Variant | ItemKind::GenericParam
            // are not directly represented as top-level GraphNode types this way.
            _ => false,
        }
    }

    fn kind(&self) -> ItemKind {
        // Check for Method first as it might overlap with Function if not careful
        if self.as_method().is_some() {
            ItemKind::Method // Method is more specific
        } else if self.as_function().is_some() {
            ItemKind::Function // Standalone function
        } else if self.as_struct().is_some() {
            ItemKind::Struct
        } else if self.as_enum().is_some() {
            ItemKind::Enum
        } else if self.as_union().is_some() {
            ItemKind::Union
        } else if self.as_type_alias().is_some() {
            ItemKind::TypeAlias
        } else if self.as_trait().is_some() {
            ItemKind::Trait
        } else if self.as_impl().is_some() {
            ItemKind::Impl
        } else if self.as_module().is_some() {
            ItemKind::Module
        } else if self.as_macro().is_some() {
            ItemKind::Macro
        } else if self.as_import().is_some() {
            // Check for extern crate specifically within import
            if self.kind_matches(ItemKind::ExternCrate) {
                ItemKind::ExternCrate
            } else {
                ItemKind::Import
            }
        } else if self.as_static().is_some() {
            // Updated check order
            ItemKind::Static
        } else if self.as_const().is_some() {
            // Updated check order
            ItemKind::Const
        } else {
            // This panic indicates a GraphNode implementation is missing a corresponding
            // 'as_xxx' method or the kind() logic here is incomplete.
            panic!(
                "Unknown GraphNode kind encountered. Name: {}, ID: {}",
                self.name(),
                self.id()
            )
        }

        // ItemKind::Field | ItemKind::Variant | ItemKind::GenericParam | ItemKind::ExternCrate
        // are not directly represented as top-level GraphNode types this way.
    }

    fn log_node_debug(&self) {
        debug!(target: LOG_TARGET_NODE,
            "{} {: <12} {: <20} | {: <12} | {: <15}",
            "NodeInfo".log_header(),
            self.name().log_name(),
            self.id().to_string().log_id(),
            self.kind().log_vis_debug(),
            self.visibility().log_name_debug(),
        );
    }

    fn log_node_error(&self) {
        log::error!(target: LOG_TARGET_NODE,
            "{} {} {: <12} {: <20} | {: <12} | {: <15}",
            "ERROR".log_error(),
            "NodeInfo".log_header(),
            self.name().log_name(),
            self.id().to_string().log_id(),
            self.kind().log_vis_debug(),
            self.visibility().log_name_debug(),
        );
    }

    // Add others like VariantNode, FieldNode if they implement GraphNode directly
}

// Shared error types
#[derive(Debug, thiserror::Error, Clone, PartialEq)] // Removed Eq because TypeId might not be Eq
pub enum NodeError {
    #[error("Invalid node configuration: {0}")]
    Validation(String),

    #[error("Invalid node converstion from TypeId, expected NodeId: {0}")] // Updated error message
    Conversion(TypeId),
    // Removed GraphIdConversion variant
}
