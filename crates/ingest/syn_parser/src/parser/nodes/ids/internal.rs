//! Private implementation module for strictly encapsulated typed node identifiers.
//!
//! Defines the ID newtype structs with private fields, implements necessary traits
//! internally, provides restricted constructors, and defines helper types like
//! `AnyNodeId`. Access to the base `NodeId` is confined to this module.

// We will move ID definitions, trait implementations, etc., here later.
use super::*;
use std::borrow::Borrow;
use std::fmt::Display;

// Example structure (will be generated by macro later)
// #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
// pub struct ExampleNodeId(NodeId);
//
// impl ExampleNodeId {
//     // Constructor restricted to crate::parser::nodes module
//     pub(in crate::parser::nodes) fn create(id: NodeId) -> Self { Self(id) }
//     // Internal access to base ID
//     pub(super) fn base_id(&self) -> NodeId { self.0 }
// }
// // Manual trait impls needed because field is private
// // Display can delegate publicly if needed via re-export
// impl fmt::Display for ExampleNodeId { fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "{}", self.0) } }
// // Borrow/AsRef might need internal impl if base ID access is restricted
// impl Borrow<NodeId> for ExampleNodeId { fn borrow(&self) -> &NodeId { &self.0 } }
// impl AsRef<NodeId> for ExampleNodeId { fn as_ref(&self) -> &NodeId { &self.0 } }

// Define AnyNodeId enum here later
// Define marker traits (TypedId, PrimaryNodeIdTrait, etc.) here later
// Define TypedNodeIdGet trait here later
// Define private sealing trait here later

// ----- Internal Macro for Typed IDs -----

/// Macro to define a strictly encapsulated newtype wrapper around NodeId.
///
/// Generates:
/// - A public struct `StructName(NodeId)` where the `NodeId` field is private.
/// - Derives: Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord.
/// - `impl StructName`:
///   - `pub(in crate::parser::nodes) fn create(NodeId) -> Self`: Restricted constructor.
///   - `pub(super) fn base_id(&self) -> NodeId`: Internal access to the base ID.
/// - `impl Display for StructName` (delegates to inner NodeId).
/// - `impl Borrow<NodeId>` and `impl AsRef<NodeId>` for internal use if needed (though direct access via `base_id` might be preferred).
///
/// # Usage (within this module)
/// ```ignore
/// define_internal_node_id!(
///     #[doc = "Identifier for a function node."] // Optional outer attributes
///     FunctionNodeId
/// );
/// ```
macro_rules! define_internal_node_id {
    ($(#[$outer:meta])* $NewTypeId:ident) => {
        $(#[$outer])*
        // The struct is pub, but its field NodeId is private by default
        // because NodeId itself is not pub in this scope after potential future refactoring
        // or simply because tuple struct fields are private without `pub`.
        #[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
        pub struct $NewTypeId(NodeId);

        impl $NewTypeId {
            /// Creates a new typed ID. Restricted constructor.
            /// Only code within `crate::parser::nodes` can call this.
            /// Ensures typed IDs are only created alongside actual node construction.
            #[inline]
            pub(in crate::parser::nodes) fn create(id: NodeId) -> Self {
                Self(id)
            }

            /// Get the underlying base NodeId.
            /// Restricted visibility (`pub(super)`) allows access only within the `ids` module.
            /// This is the controlled escape hatch for internal operations like hashing,
            /// indexing in generic maps, or passing context to ploke-core.
            #[inline]
            pub(super) fn base_id(&self) -> NodeId {
                self.0
            }

            // We intentionally DO NOT provide public or pub(crate) `into_inner` or `as_inner`.
            // Access to the base ID outside this module should be impossible.
        }

        impl std::fmt::Display for $NewTypeId {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                // Delegate to the inner NodeId's Display implementation
                write!(f, "{}", self.0)
            }
        }

        // These Borrow/AsRef impls might be useful for internal generic code
        // within the `ids` module that needs to operate on the base ID without
        // consuming the wrapper. However, calling `base_id()` might be clearer.
        // Keep them commented out unless a clear need arises.
        // impl std::borrow::Borrow<NodeId> for $NewTypeId {
        //     #[inline]
        //     fn borrow(&self) -> &NodeId {
        //         &self.0
        //     }
        // }
        //
        // impl AsRef<NodeId> for $NewTypeId {
        //     #[inline]
        //     fn as_ref(&self) -> &NodeId {
        //         &self.0
        //     }
        // }

        // Placeholder for implementing marker traits via the macro later
        // impl $crate::parser::nodes::ids::internal::TypedId for $NewTypeId {}
        // // Example: Add marker trait implementation based on macro input
        // // define_internal_node_id!(StructNodeId, marker: PrimaryNodeIdTrait);
        // // macro_rules! define_internal_node_id {
        // //     ($NewTypeId:ident $(, marker: $MarkerTrait:path)*) => { ... $(impl $MarkerTrait for $NewTypeId {})* ... }
        // // }
    };
}

// Now use the *new* internal macro
define_internal_node_id!(EnumNodeId);
define_internal_node_id!(FunctionNodeId); // For standalone functions
define_internal_node_id!(MethodNodeId); // For associated functions/methods
define_internal_node_id!(ImplNodeId);
define_internal_node_id!(ImportNodeId);
define_internal_node_id!(ModuleNodeId); // Use the macro now, assuming no special manual impl needed yet
define_internal_node_id!(StructNodeId);
define_internal_node_id!(TraitNodeId);
define_internal_node_id!(TypeAliasNodeId);
define_internal_node_id!(UnionNodeId);
// Removed ValueNodeId
define_internal_node_id!(ConstNodeId); // Added
define_internal_node_id!(StaticNodeId); // Added
define_internal_node_id!(FieldNodeId);
define_internal_node_id!(VariantNodeId);
define_internal_node_id!(ParamNodeId); // For ParamData
define_internal_node_id!(GenericParamNodeId);
define_internal_node_id!(MacroNodeId);

// For more explicit differntiation within Phase 3 module tree processing
define_internal_node_id!(ReexportNodeId);
// --- Category ID Enums ---

use ploke_core::ItemKind; // Need ItemKind for kind() methods

pub trait PrimaryNodeMarker {}

impl PrimaryNodeMarker for FunctionNode {}
impl PrimaryNodeMarker for StructNode {}
impl PrimaryNodeMarker for UnionNode {}
impl PrimaryNodeMarker for EnumNode {}
impl PrimaryNodeMarker for TypeAliasNode {}
impl PrimaryNodeMarker for TraitNode {}
impl PrimaryNodeMarker for ImplNode {}
impl PrimaryNodeMarker for ConstNode {}
impl PrimaryNodeMarker for StaticNode {}
impl PrimaryNodeMarker for MacroNode {}
impl PrimaryNodeMarker for ImportNode {}
impl PrimaryNodeMarker for ModuleNode {}

// ------------------------------------------------------------
// -----------------begin example------------------------------
use crate::parser::graph::GraphAccess;
use ploke_core::NodeId;
use std::hash::{Hash, Hasher}; // Public trait

// --- ID Structs (Field private) ---
#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq, PartialOrd, Ord)]
pub struct ExampleNodeId(NodeId);
// ... others ...
// --- Internal Base ID Access ---
trait HasBaseId {
    fn base_id(&self) -> NodeId;
}
impl HasBaseId for ExampleNodeId {
    fn base_id(&self) -> NodeId {
        self.0
    }
}
pub trait TypedId {}
pub trait PrimaryNodeIdTrait {}
mod private_traits {
    pub(super) trait Sealed {}
}
// ... others ...

// --- Marker Trait Impls ---
impl TypedId for ExampleNodeId {}
impl PrimaryNodeIdTrait for ExampleNodeId {}
// ... others ...

// --- TypedNodeIdGet Trait Def & Impls ---
pub trait TypedNodeIdGet /* ... */ {
    /* ... */
} // Define here or re-export public one
impl private_traits::Sealed for ExampleNodeId {}
impl TypedNodeIdGet for ExampleNodeId {
    /* ... calls graph.get_struct(self) ... */
}
// ... others ...

// --- Restricted Constructors ---
impl ExampleNodeId {
    pub(super) fn create(id: NodeId) -> Self {
        Self(id)
    }
}
// ... others ...

// --- Heterogeneous Key (Option 1 Example) ---
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum AnyNodeId {
    Struct(ExampleNodeId), /* ... */
}

// ------------------end example-------------------------------
// ------------------------------------------------------------

/// Represents the ID of any node type that can typically be defined directly
/// within a module scope (primary items).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
pub enum PrimaryNodeId {
    Function(FunctionNodeId),
    Struct(StructNodeId),
    Enum(EnumNodeId),
    Union(UnionNodeId),
    TypeAlias(TypeAliasNodeId),
    Trait(TraitNodeId),
    Impl(ImplNodeId),
    Const(ConstNodeId),   // Changed from Value
    Static(StaticNodeId), // Added
    Macro(MacroNodeId),
    Import(ImportNodeId),
    Module(ModuleNodeId),
}

impl PrimaryNodeId {
    /// Returns the underlying base NodeId using the internal `base_id` method.
    pub fn base_id(&self) -> NodeId {
        match *self {
            PrimaryNodeId::Function(id) => id.base_id(),
            PrimaryNodeId::Struct(id) => id.base_id(),
            PrimaryNodeId::Enum(id) => id.base_id(),
            PrimaryNodeId::Union(id) => id.base_id(),
            PrimaryNodeId::TypeAlias(id) => id.base_id(),
            PrimaryNodeId::Trait(id) => id.base_id(),
            PrimaryNodeId::Impl(id) => id.base_id(),
            PrimaryNodeId::Const(id) => id.base_id(),
            PrimaryNodeId::Static(id) => id.base_id(),
            PrimaryNodeId::Macro(id) => id.base_id(),
            PrimaryNodeId::Import(id) => id.base_id(),
            PrimaryNodeId::Module(id) => id.base_id(),
        }
    }

    // Optional: Get the ItemKind directly
    pub fn kind(&self) -> ItemKind {
        match self {
            PrimaryNodeId::Function(_) => ItemKind::Function,
            PrimaryNodeId::Struct(_) => ItemKind::Struct,
            PrimaryNodeId::Enum(_) => ItemKind::Enum,
            PrimaryNodeId::Union(_) => ItemKind::Union,
            PrimaryNodeId::TypeAlias(_) => ItemKind::TypeAlias,
            PrimaryNodeId::Trait(_) => ItemKind::Trait,
            PrimaryNodeId::Impl(_) => ItemKind::Impl,
            PrimaryNodeId::Const(_) => ItemKind::Const, // Changed from Value
            PrimaryNodeId::Static(_) => ItemKind::Static, // Added
            PrimaryNodeId::Macro(_) => ItemKind::Macro,
            PrimaryNodeId::Import(_) => ItemKind::Import,
            PrimaryNodeId::Module(_) => ItemKind::Module,
        }
    }
}

/// Represents the ID of any node type that can be an associated item
/// within an `impl` or `trait` block.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
pub enum AssociatedItemId {
    Method(MethodNodeId),       // Associated function/method (changed from Function)
    TypeAlias(TypeAliasNodeId), // Associated type
    Const(ConstNodeId),         // Associated const
}

impl AssociatedItemId {
    /// Returns the underlying base NodeId using the internal `base_id` method.
    pub fn base_id(&self) -> NodeId {
        match *self {
            AssociatedItemId::Method(id) => id.base_id(),
            AssociatedItemId::TypeAlias(id) => id.base_id(),
            AssociatedItemId::Const(id) => id.base_id(),
        }
    }

    // Optional: Get the ItemKind directly
    pub fn kind(&self) -> ItemKind {
        match self {
            AssociatedItemId::Method(_) => ItemKind::Method, // Changed from Function
            AssociatedItemId::TypeAlias(_) => ItemKind::TypeAlias,
            AssociatedItemId::Const(_) => ItemKind::Const,
        }
    }
}

// --- From Implementations for Category Enums ---
impl From<FunctionNodeId> for PrimaryNodeId {
    // Standalone Function
    fn from(id: FunctionNodeId) -> Self {
        PrimaryNodeId::Function(id)
    }
}
impl From<StructNodeId> for PrimaryNodeId {
    fn from(id: StructNodeId) -> Self {
        PrimaryNodeId::Struct(id)
    }
}
impl From<EnumNodeId> for PrimaryNodeId {
    fn from(id: EnumNodeId) -> Self {
        PrimaryNodeId::Enum(id)
    }
}
impl From<UnionNodeId> for PrimaryNodeId {
    fn from(id: UnionNodeId) -> Self {
        PrimaryNodeId::Union(id)
    }
}
impl From<TypeAliasNodeId> for PrimaryNodeId {
    fn from(id: TypeAliasNodeId) -> Self {
        PrimaryNodeId::TypeAlias(id)
    }
}
impl From<TraitNodeId> for PrimaryNodeId {
    fn from(id: TraitNodeId) -> Self {
        PrimaryNodeId::Trait(id)
    }
}
impl From<ImplNodeId> for PrimaryNodeId {
    fn from(id: ImplNodeId) -> Self {
        PrimaryNodeId::Impl(id)
    }
}
// Removed From<ValueNodeId>
impl From<ConstNodeId> for PrimaryNodeId {
    fn from(id: ConstNodeId) -> Self {
        PrimaryNodeId::Const(id)
    }
} // Added
impl From<StaticNodeId> for PrimaryNodeId {
    fn from(id: StaticNodeId) -> Self {
        PrimaryNodeId::Static(id)
    }
} // Added
impl From<MacroNodeId> for PrimaryNodeId {
    fn from(id: MacroNodeId) -> Self {
        PrimaryNodeId::Macro(id)
    }
}
impl From<ImportNodeId> for PrimaryNodeId {
    fn from(id: ImportNodeId) -> Self {
        PrimaryNodeId::Import(id)
    }
}
impl From<ModuleNodeId> for PrimaryNodeId {
    fn from(id: ModuleNodeId) -> Self {
        PrimaryNodeId::Module(id)
    }
}

// Removed From<FunctionNodeId> for AssociatedItemId
impl From<MethodNodeId> for AssociatedItemId {
    // Method
    fn from(id: MethodNodeId) -> Self {
        AssociatedItemId::Method(id)
    }
}
impl From<TypeAliasNodeId> for AssociatedItemId {
    fn from(id: TypeAliasNodeId) -> Self {
        AssociatedItemId::TypeAlias(id)
    }
}
// Removed From<ValueNodeId>
impl From<ConstNodeId> for AssociatedItemId {
    fn from(id: ConstNodeId) -> Self {
        AssociatedItemId::Const(id)
    }
} // Added

// --- Node Struct Definitions ---
// Logging target
const LOG_TARGET_NODE: &str = "node_info"; // Define log target for visibility checks

// end up needing access to NodeId
/// Core trait for all graph nodes
pub trait GraphNode {
    fn id(&self) -> NodeId;
    fn visibility(&self) -> &VisibilityKind;
    fn name(&self) -> &str;
    fn cfgs(&self) -> &[String];

    // --- Default implementations for downcasting ---
    fn as_function(&self) -> Option<&FunctionNode> {
        // Standalone function
        None
    }
    fn as_method(&self) -> Option<&MethodNode> {
        // Associated function/method
        None
    }
    fn as_struct(&self) -> Option<&StructNode> {
        None
    }
    fn as_enum(&self) -> Option<&EnumNode> {
        None
    }
    fn as_union(&self) -> Option<&UnionNode> {
        None
    }
    fn as_type_alias(&self) -> Option<&TypeAliasNode> {
        None
    }
    fn as_trait(&self) -> Option<&TraitNode> {
        None
    }
    fn as_impl(&self) -> Option<&ImplNode> {
        None
    }
    fn as_module(&self) -> Option<&ModuleNode> {
        None
    }
    fn as_const(&self) -> Option<&ConstNode> {
        // Added
        None
    }
    fn as_static(&self) -> Option<&StaticNode> {
        // Added
        None
    }
    fn as_macro(&self) -> Option<&MacroNode> {
        None
    }
    fn as_import(&self) -> Option<&ImportNode> {
        None
    }
    fn kind_matches(&self, kind: ItemKind) -> bool {
        match kind {
            ItemKind::Function => self.as_function().is_some(), // Matches standalone functions
            ItemKind::Method => self.as_method().is_some(), // Matches associated functions/methods
            ItemKind::Struct => self.as_struct().is_some(),
            ItemKind::Enum => self.as_enum().is_some(),
            ItemKind::Union => self.as_union().is_some(),
            ItemKind::TypeAlias => self.as_type_alias().is_some(),
            ItemKind::Trait => self.as_trait().is_some(),
            ItemKind::Impl => self.as_impl().is_some(),
            ItemKind::Module => self.as_module().is_some(),
            ItemKind::Const => self.as_const().is_some(), // Updated
            ItemKind::Static => self.as_static().is_some(), // Updated
            ItemKind::Macro => self.as_macro().is_some(),
            ItemKind::Import => self.as_import().is_some(),
            ItemKind::ExternCrate => {
                // kind of a hack job. needs cleaner solution
                if let Some(import_node) = self.as_import() {
                    // Use if let for safety
                    import_node.is_extern_crate()
                } else {
                    false
                }
            }

            // ItemKind::Field | ItemKind::Variant | ItemKind::GenericParam
            // are not directly represented as top-level GraphNode types this way.
            _ => false,
        }
    }

    fn kind(&self) -> ItemKind {
        // Check for Method first as it might overlap with Function if not careful
        if self.as_method().is_some() {
            ItemKind::Method // Method is more specific
        } else if self.as_function().is_some() {
            ItemKind::Function // Standalone function
        } else if self.as_struct().is_some() {
            ItemKind::Struct
        } else if self.as_enum().is_some() {
            ItemKind::Enum
        } else if self.as_union().is_some() {
            ItemKind::Union
        } else if self.as_type_alias().is_some() {
            ItemKind::TypeAlias
        } else if self.as_trait().is_some() {
            ItemKind::Trait
        } else if self.as_impl().is_some() {
            ItemKind::Impl
        } else if self.as_module().is_some() {
            ItemKind::Module
        } else if self.as_macro().is_some() {
            ItemKind::Macro
        } else if self.as_import().is_some() {
            // Check for extern crate specifically within import
            if self.kind_matches(ItemKind::ExternCrate) {
                ItemKind::ExternCrate
            } else {
                ItemKind::Import
            }
        } else if self.as_static().is_some() {
            // Updated check order
            ItemKind::Static
        } else if self.as_const().is_some() {
            // Updated check order
            ItemKind::Const
        } else {
            // This panic indicates a GraphNode implementation is missing a corresponding
            // 'as_xxx' method or the kind() logic here is incomplete.
            panic!(
                "Unknown GraphNode kind encountered. Name: {}, ID: {}",
                self.name(),
                self.id()
            )
        }

        // ItemKind::Field | ItemKind::Variant | ItemKind::GenericParam | ItemKind::ExternCrate
        // are not directly represented as top-level GraphNode types this way.
    }

    fn log_node_debug(&self) {
        debug!(target: LOG_TARGET_NODE,
            "{} {: <12} {: <20} | {: <12} | {: <15}",
            "NodeInfo".log_header(),
            self.name().log_name(),
            self.id().to_string().log_id(),
            self.kind().log_vis_debug(),
            self.visibility().log_name_debug(),
        );
    }

    fn log_node_error(&self) {
        log::error!(target: LOG_TARGET_NODE,
            "{} {} {: <12} {: <20} | {: <12} | {: <15}",
            "ERROR".log_error(),
            "NodeInfo".log_header(),
            self.name().log_name(),
            self.id().to_string().log_id(),
            self.kind().log_vis_debug(),
            self.visibility().log_name_debug(),
        );
    }

    // Add others like VariantNode, FieldNode if they implement GraphNode directly
}

// Shared error types
#[derive(Debug, thiserror::Error, Clone, PartialEq)] // Removed Eq because TypeId might not be Eq
pub enum NodeError {
    #[error("Invalid node configuration: {0}")]
    Validation(String),

    #[error("Invalid node converstion from TypeId, expected NodeId: {0}")] // Updated error message
    Conversion(TypeId),
    // Removed GraphIdConversion variant
}
