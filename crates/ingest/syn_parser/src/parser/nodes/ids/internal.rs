//! Private implementation module for strictly encapsulated typed node identifiers.
//!
//! Defines the ID newtype structs with private fields, implements necessary traits
//! internally, provides restricted constructors, and defines helper types like
//! `AnyNodeId`. Access to the base `NodeId` is confined to this module.

// We will move ID definitions, trait implementations, etc., here later.
use super::*;
use std::borrow::Borrow;
use std::fmt::Display;

// Example structure (will be generated by macro later)
// #[derive(Debug, Clone, Copy, Serialize, Deserialize)]
// pub struct ExampleNodeId(NodeId);
//
// impl ExampleNodeId {
//     // Constructor restricted to crate::parser::nodes module
//     pub(in crate::parser::nodes) fn create(id: NodeId) -> Self { Self(id) }
//     // Internal access to base ID
//     pub(super) fn base_id(&self) -> NodeId { self.0 }
// }
// // Manual trait impls needed because field is private
// // Display can delegate publicly if needed via re-export
// impl fmt::Display for ExampleNodeId { fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result { write!(f, "{}", self.0) } }
// // Borrow/AsRef might need internal impl if base ID access is restricted
// impl Borrow<NodeId> for ExampleNodeId { fn borrow(&self) -> &NodeId { &self.0 } }
// impl AsRef<NodeId> for ExampleNodeId { fn as_ref(&self) -> &NodeId { &self.0 } }

// Define AnyNodeId enum here later
// Define marker traits (TypedId, PrimaryNodeIdTrait, etc.) here later
// Define TypedNodeIdGet trait here later
// Define private sealing trait here later

// ----- utility macro -----
define_node_id_wrapper!(EnumNodeId);
define_node_id_wrapper!(FunctionNodeId); // For standalone functions
define_node_id_wrapper!(MethodNodeId); // For associated functions/methods
define_node_id_wrapper!(ImplNodeId);
define_node_id_wrapper!(ImportNodeId);
define_node_id_wrapper!(ModuleNodeId);
define_node_id_wrapper!(StructNodeId);
define_node_id_wrapper!(TraitNodeId);
define_node_id_wrapper!(TypeAliasNodeId);
define_node_id_wrapper!(UnionNodeId);
// Removed ValueNodeId
define_node_id_wrapper!(ConstNodeId); // Added
define_node_id_wrapper!(StaticNodeId); // Added
define_node_id_wrapper!(FieldNodeId);
define_node_id_wrapper!(VariantNodeId);
define_node_id_wrapper!(ParamNodeId); // For ParamData
define_node_id_wrapper!(GenericParamNodeId);
define_node_id_wrapper!(MacroNodeId);
// For more explicit differntiation within Phase 3 module tree processing
define_node_id_wrapper!(ReexportNodeId);
// --- Category ID Enums ---

use ploke_core::ItemKind; // Need ItemKind for kind() methods

pub trait PrimaryNodeMarker {}

impl PrimaryNodeMarker for FunctionNode {}
impl PrimaryNodeMarker for StructNode {}
impl PrimaryNodeMarker for UnionNode {}
impl PrimaryNodeMarker for EnumNode {}
impl PrimaryNodeMarker for TypeAliasNode {}
impl PrimaryNodeMarker for TraitNode {}
impl PrimaryNodeMarker for ImplNode {}
impl PrimaryNodeMarker for ConstNode {}
impl PrimaryNodeMarker for StaticNode {}
impl PrimaryNodeMarker for MacroNode {}
impl PrimaryNodeMarker for ImportNode {}
impl PrimaryNodeMarker for ModuleNode {}

// ------------------------------------------------------------
// -----------------begin example------------------------------
use crate::parser::graph::GraphAccess;
use ploke_core::NodeId;
use std::hash::{Hash, Hasher}; // Public trait

// --- ID Structs (Field private) ---
#[derive(Debug, Clone, Copy, Hash, Eq, PartialEq, PartialOrd, Ord)]
pub struct ExampleNodeId(NodeId);
// ... others ...
// --- Internal Base ID Access ---
trait HasBaseId {
    fn base_id(&self) -> NodeId;
}
impl HasBaseId for ExampleNodeId {
    fn base_id(&self) -> NodeId {
        self.0
    }
}
pub trait TypedId {}
pub trait PrimaryNodeIdTrait {}
mod private_traits {
    pub(super) trait Sealed {}
}
// ... others ...

// --- Marker Trait Impls ---
impl TypedId for ExampleNodeId {}
impl PrimaryNodeIdTrait for ExampleNodeId {}
// ... others ...

// --- TypedNodeIdGet Trait Def & Impls ---
pub trait TypedNodeIdGet /* ... */ {
    /* ... */
} // Define here or re-export public one
impl private_traits::Sealed for ExampleNodeId {}
impl TypedNodeIdGet for ExampleNodeId {
    /* ... calls graph.get_struct(self) ... */
}
// ... others ...

// --- Restricted Constructors ---
impl ExampleNodeId {
    pub(super) fn create(id: NodeId) -> Self {
        Self(id)
    }
}
// ... others ...

// --- Heterogeneous Key (Option 1 Example) ---
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash)]
pub enum AnyNodeId {
    Struct(ExampleNodeId), /* ... */
}

// ------------------end example-------------------------------
// ------------------------------------------------------------

/// Represents the ID of any node type that can typically be defined directly
/// within a module scope (primary items).
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
pub enum PrimaryNodeId {
    Function(FunctionNodeId),
    Struct(StructNodeId),
    Enum(EnumNodeId),
    Union(UnionNodeId),
    TypeAlias(TypeAliasNodeId),
    Trait(TraitNodeId),
    Impl(ImplNodeId),
    Const(ConstNodeId),   // Changed from Value
    Static(StaticNodeId), // Added
    Macro(MacroNodeId),
    Import(ImportNodeId),
    Module(ModuleNodeId),
}

impl PrimaryNodeId {
    /// Returns the underlying base NodeId.
    pub fn base_id(&self) -> NodeId {
        match *self {
            PrimaryNodeId::Function(id) => id.into_inner(),
            PrimaryNodeId::Struct(id) => id.into_inner(),
            PrimaryNodeId::Enum(id) => id.into_inner(),
            PrimaryNodeId::Union(id) => id.into_inner(),
            PrimaryNodeId::TypeAlias(id) => id.into_inner(),
            PrimaryNodeId::Trait(id) => id.into_inner(),
            PrimaryNodeId::Impl(id) => id.into_inner(),
            PrimaryNodeId::Const(id) => id.into_inner(), // Changed from Value
            PrimaryNodeId::Static(id) => id.into_inner(), // Added
            PrimaryNodeId::Macro(id) => id.into_inner(),
            PrimaryNodeId::Import(id) => id.into_inner(),
            PrimaryNodeId::Module(id) => id.into_inner(),
        }
    }

    // Optional: Get the ItemKind directly
    pub fn kind(&self) -> ItemKind {
        match self {
            PrimaryNodeId::Function(_) => ItemKind::Function,
            PrimaryNodeId::Struct(_) => ItemKind::Struct,
            PrimaryNodeId::Enum(_) => ItemKind::Enum,
            PrimaryNodeId::Union(_) => ItemKind::Union,
            PrimaryNodeId::TypeAlias(_) => ItemKind::TypeAlias,
            PrimaryNodeId::Trait(_) => ItemKind::Trait,
            PrimaryNodeId::Impl(_) => ItemKind::Impl,
            PrimaryNodeId::Const(_) => ItemKind::Const, // Changed from Value
            PrimaryNodeId::Static(_) => ItemKind::Static, // Added
            PrimaryNodeId::Macro(_) => ItemKind::Macro,
            PrimaryNodeId::Import(_) => ItemKind::Import,
            PrimaryNodeId::Module(_) => ItemKind::Module,
        }
    }
}

/// Represents the ID of any node type that can be an associated item
/// within an `impl` or `trait` block.
#[derive(Debug, Clone, Copy, PartialEq, Eq, Hash, Serialize, Deserialize, PartialOrd, Ord)]
pub enum AssociatedItemId {
    Method(MethodNodeId),       // Associated function/method (changed from Function)
    TypeAlias(TypeAliasNodeId), // Associated type
    Const(ConstNodeId),         // Associated const
}

impl AssociatedItemId {
    /// Returns the underlying base NodeId.
    pub fn base_id(&self) -> NodeId {
        match *self {
            AssociatedItemId::Method(id) => id.into_inner(), // Changed from Function
            AssociatedItemId::TypeAlias(id) => id.into_inner(),
            AssociatedItemId::Const(id) => id.into_inner(),
        }
    }

    // Optional: Get the ItemKind directly
    pub fn kind(&self) -> ItemKind {
        match self {
            AssociatedItemId::Method(_) => ItemKind::Method, // Changed from Function
            AssociatedItemId::TypeAlias(_) => ItemKind::TypeAlias,
            AssociatedItemId::Const(_) => ItemKind::Const,
        }
    }
}

// --- From Implementations for Category Enums ---
impl From<FunctionNodeId> for PrimaryNodeId {
    // Standalone Function
    fn from(id: FunctionNodeId) -> Self {
        PrimaryNodeId::Function(id)
    }
}
impl From<StructNodeId> for PrimaryNodeId {
    fn from(id: StructNodeId) -> Self {
        PrimaryNodeId::Struct(id)
    }
}
impl From<EnumNodeId> for PrimaryNodeId {
    fn from(id: EnumNodeId) -> Self {
        PrimaryNodeId::Enum(id)
    }
}
impl From<UnionNodeId> for PrimaryNodeId {
    fn from(id: UnionNodeId) -> Self {
        PrimaryNodeId::Union(id)
    }
}
impl From<TypeAliasNodeId> for PrimaryNodeId {
    fn from(id: TypeAliasNodeId) -> Self {
        PrimaryNodeId::TypeAlias(id)
    }
}
impl From<TraitNodeId> for PrimaryNodeId {
    fn from(id: TraitNodeId) -> Self {
        PrimaryNodeId::Trait(id)
    }
}
impl From<ImplNodeId> for PrimaryNodeId {
    fn from(id: ImplNodeId) -> Self {
        PrimaryNodeId::Impl(id)
    }
}
// Removed From<ValueNodeId>
impl From<ConstNodeId> for PrimaryNodeId {
    fn from(id: ConstNodeId) -> Self {
        PrimaryNodeId::Const(id)
    }
} // Added
impl From<StaticNodeId> for PrimaryNodeId {
    fn from(id: StaticNodeId) -> Self {
        PrimaryNodeId::Static(id)
    }
} // Added
impl From<MacroNodeId> for PrimaryNodeId {
    fn from(id: MacroNodeId) -> Self {
        PrimaryNodeId::Macro(id)
    }
}
impl From<ImportNodeId> for PrimaryNodeId {
    fn from(id: ImportNodeId) -> Self {
        PrimaryNodeId::Import(id)
    }
}
impl From<ModuleNodeId> for PrimaryNodeId {
    fn from(id: ModuleNodeId) -> Self {
        PrimaryNodeId::Module(id)
    }
}

// Removed From<FunctionNodeId> for AssociatedItemId
impl From<MethodNodeId> for AssociatedItemId {
    // Method
    fn from(id: MethodNodeId) -> Self {
        AssociatedItemId::Method(id)
    }
}
impl From<TypeAliasNodeId> for AssociatedItemId {
    fn from(id: TypeAliasNodeId) -> Self {
        AssociatedItemId::TypeAlias(id)
    }
}
// Removed From<ValueNodeId>
impl From<ConstNodeId> for AssociatedItemId {
    fn from(id: ConstNodeId) -> Self {
        AssociatedItemId::Const(id)
    }
} // Added

// --- Node Struct Definitions ---
// Logging target
const LOG_TARGET_NODE: &str = "node_info"; // Define log target for visibility checks

// end up needing access to NodeId
/// Core trait for all graph nodes
pub trait GraphNode {
    fn id(&self) -> NodeId;
    fn visibility(&self) -> &VisibilityKind;
    fn name(&self) -> &str;
    fn cfgs(&self) -> &[String];

    // --- Default implementations for downcasting ---
    fn as_function(&self) -> Option<&FunctionNode> {
        // Standalone function
        None
    }
    fn as_method(&self) -> Option<&MethodNode> {
        // Associated function/method
        None
    }
    fn as_struct(&self) -> Option<&StructNode> {
        None
    }
    fn as_enum(&self) -> Option<&EnumNode> {
        None
    }
    fn as_union(&self) -> Option<&UnionNode> {
        None
    }
    fn as_type_alias(&self) -> Option<&TypeAliasNode> {
        None
    }
    fn as_trait(&self) -> Option<&TraitNode> {
        None
    }
    fn as_impl(&self) -> Option<&ImplNode> {
        None
    }
    fn as_module(&self) -> Option<&ModuleNode> {
        None
    }
    fn as_const(&self) -> Option<&ConstNode> {
        // Added
        None
    }
    fn as_static(&self) -> Option<&StaticNode> {
        // Added
        None
    }
    fn as_macro(&self) -> Option<&MacroNode> {
        None
    }
    fn as_import(&self) -> Option<&ImportNode> {
        None
    }
    fn kind_matches(&self, kind: ItemKind) -> bool {
        match kind {
            ItemKind::Function => self.as_function().is_some(), // Matches standalone functions
            ItemKind::Method => self.as_method().is_some(), // Matches associated functions/methods
            ItemKind::Struct => self.as_struct().is_some(),
            ItemKind::Enum => self.as_enum().is_some(),
            ItemKind::Union => self.as_union().is_some(),
            ItemKind::TypeAlias => self.as_type_alias().is_some(),
            ItemKind::Trait => self.as_trait().is_some(),
            ItemKind::Impl => self.as_impl().is_some(),
            ItemKind::Module => self.as_module().is_some(),
            ItemKind::Const => self.as_const().is_some(), // Updated
            ItemKind::Static => self.as_static().is_some(), // Updated
            ItemKind::Macro => self.as_macro().is_some(),
            ItemKind::Import => self.as_import().is_some(),
            ItemKind::ExternCrate => {
                // kind of a hack job. needs cleaner solution
                if let Some(import_node) = self.as_import() {
                    // Use if let for safety
                    import_node.is_extern_crate()
                } else {
                    false
                }
            }

            // ItemKind::Field | ItemKind::Variant | ItemKind::GenericParam
            // are not directly represented as top-level GraphNode types this way.
            _ => false,
        }
    }

    fn kind(&self) -> ItemKind {
        // Check for Method first as it might overlap with Function if not careful
        if self.as_method().is_some() {
            ItemKind::Method // Method is more specific
        } else if self.as_function().is_some() {
            ItemKind::Function // Standalone function
        } else if self.as_struct().is_some() {
            ItemKind::Struct
        } else if self.as_enum().is_some() {
            ItemKind::Enum
        } else if self.as_union().is_some() {
            ItemKind::Union
        } else if self.as_type_alias().is_some() {
            ItemKind::TypeAlias
        } else if self.as_trait().is_some() {
            ItemKind::Trait
        } else if self.as_impl().is_some() {
            ItemKind::Impl
        } else if self.as_module().is_some() {
            ItemKind::Module
        } else if self.as_macro().is_some() {
            ItemKind::Macro
        } else if self.as_import().is_some() {
            // Check for extern crate specifically within import
            if self.kind_matches(ItemKind::ExternCrate) {
                ItemKind::ExternCrate
            } else {
                ItemKind::Import
            }
        } else if self.as_static().is_some() {
            // Updated check order
            ItemKind::Static
        } else if self.as_const().is_some() {
            // Updated check order
            ItemKind::Const
        } else {
            // This panic indicates a GraphNode implementation is missing a corresponding
            // 'as_xxx' method or the kind() logic here is incomplete.
            panic!(
                "Unknown GraphNode kind encountered. Name: {}, ID: {}",
                self.name(),
                self.id()
            )
        }

        // ItemKind::Field | ItemKind::Variant | ItemKind::GenericParam | ItemKind::ExternCrate
        // are not directly represented as top-level GraphNode types this way.
    }

    fn log_node_debug(&self) {
        debug!(target: LOG_TARGET_NODE,
            "{} {: <12} {: <20} | {: <12} | {: <15}",
            "NodeInfo".log_header(),
            self.name().log_name(),
            self.id().to_string().log_id(),
            self.kind().log_vis_debug(),
            self.visibility().log_name_debug(),
        );
    }

    fn log_node_error(&self) {
        log::error!(target: LOG_TARGET_NODE,
            "{} {} {: <12} {: <20} | {: <12} | {: <15}",
            "ERROR".log_error(),
            "NodeInfo".log_header(),
            self.name().log_name(),
            self.id().to_string().log_id(),
            self.kind().log_vis_debug(),
            self.visibility().log_name_debug(),
        );
    }

    // Add others like VariantNode, FieldNode if they implement GraphNode directly
}

// Shared error types
#[derive(Debug, thiserror::Error, Clone, PartialEq)] // Removed Eq because TypeId might not be Eq
pub enum NodeError {
    #[error("Invalid node configuration: {0}")]
    Validation(String),

    #[error("Invalid node converstion from TypeId, expected NodeId: {0}")] // Updated error message
    Conversion(TypeId),
    // Removed GraphIdConversion variant
}
