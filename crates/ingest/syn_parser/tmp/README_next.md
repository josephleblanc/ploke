# syn_parser

> [!WARNING]
> This README is under review and may not be accurate. It is subject to change.

<details>
<summary>Files to Document</summary>

- [ ] `src/lib.rs`
- [ ] `src/discovery.rs`
- [ ] `src/error.rs`
- [ ] `src/config/mod.rs`
- [ ] `src/config/options.rs`
- [ ] `src/parser/mod.rs`
- [ ] `src/parser/channel.rs`
- [ ] `src/parser/relations.rs`
- [ ] `src/parser/types.rs`
- [ ] `src/parser/utils.rs`
- [ ] `src/parser/visibility.rs`
- [ ] `src/parser/graph/`
- [ ] `src/parser/nodes/`
- [ ] `src/parser/visitor/`
- [ ] `src/resolve/mod.rs`
- [ ] `src/resolve/error.rs`
- [ ] `src/resolve/id_resolver.rs`
- [ ] `src/resolve/logging.rs`
- [ ] `src/resolve/module_tree.rs`
- [ ] `src/resolve/path_resolver.rs`
- [ ] `src/resolve/relation_indexer.rs`
- [ ] `src/resolve/tests.rs`
- [ ] `src/resolve/traversal.rs`
- [ ] `src/utils/mod.rs`
- [ ] `src/utils/logging.rs`
- [ ] `src/utils/test_setup.rs`

</details>


A comprehensive Rust code parser and analyzer built on the `syn` crate.

## Overview

`syn_parser` is a core component of the ploke project, responsible for parsing Rust source code into a structured graph representation. It extracts detailed information about code structure, relationships, and semantics to enable advanced code analysis and retrieval.

## Features

- **Discovery Phase**: Single-threaded walk of crate directories, parsing `Cargo.toml`, collecting `.rs` files, and producing a deterministic `CrateContext` per crate.
- **Complete Rust Syntax Support**: Parses all Rust language constructs including functions, structs, enums, traits, implementations, and modules
- **Type System Analysis**: Tracks complex type relationships, generics, and type bounds
- **Visibility Tracking**: Preserves public/private visibility information
- **Documentation Extraction**: Captures docstrings and attributes
- **Parallel Processing**: Efficiently processes multiple files concurrently using Rayon
- **Thread-safe Design**: All core data structures are Send + Sync
- **Serialization**: Exports parsed code graphs to RON format

## Architecture

The parser uses a visitor pattern to traverse the Rust AST (Abstract Syntax Tree) generated by the `syn` crate. It builds a comprehensive `CodeGraph` structure that contains:

- Functions with their signatures, parameters, and return types
- Type definitions (structs, enums, unions, type aliases)
- Trait definitions and implementations
- Module structure and visibility
- Type relationships and dependencies

## Usage

### 1. Discovery Phase (single-threaded setup)

```rust
use syn_parser::discovery::run_discovery_phase;
use std::path::PathBuf;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let project_root = PathBuf::from("/absolute/path/to/project");
    let target_crates = vec![PathBuf::from("/absolute/path/to/crate")];

    let discovery = run_discovery_phase(&project_root, &target_crates)?;

    for (_, ctx) in discovery.iter_crate_contexts() {
        println!("Crate: {} v{}  ({} .rs files)",
                 ctx.name, ctx.version, ctx.files.len());
    }
    Ok(())
}
```

### 2. Parallel Parsing (after discovery)

```rust
use syn_parser::parser::visitor::analyze_files_parallel;
use syn_parser::discovery::DiscoveryOutput;

fn continue_after_discovery(discovery: DiscoveryOutput)
        -> Result<(), Box<dyn std::error::Error>> {
    // Process all discovered files concurrently
    let graphs = analyze_files_parallel(&discovery, 0)?; // 0 = Rayon default pool
    println!("Produced {} partial graphs", graphs.len());
    Ok(())
}
```

### Serialization

```rust
use syn_parser::serialization::ron::save_to_ron;
use syn_parser::parser::visitor::analyze_code;
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let file_path = Path::new("src/main.rs");
    let code_graph = analyze_code(file_path)?;
    
    // Save to RON file
    save_to_ron(&code_graph, Path::new("output.ron"))?;
    
    Ok(())
}
```

## Documentation Strategy

This crate aims to follow the documentation style of the Tokio project, emphasizing:

- **Example-Driven Explanations**: Every major concept and API should be introduced with a clear, runnable example.
- **Focus on "What" and "How"**: Documentation should be user-centric, first explaining *what* a component does and *how* to use it effectively.
- **Crate-Level Overview**: The crate root (`lib.rs`) must provide a high-level guide, explaining the crate's purpose and how its main components fit together.
- **Testable Documentation**: All code examples are tested as part of the standard test suite to ensure they are always correct and up-to-date.
- **Complete Public API Coverage**: Every public function, struct, enum, trait, and macro must be documented. We use `#![warn(missing_docs)]` to help enforce this.

## Integration with ploke

`syn_parser` is designed to work as part of the larger ploke system:

1. It receives file paths to parse from the file watcher or UI components
2. It processes these files and generates code graphs
3. The code graphs are then passed to other components for:
   - Embedding generation
   - Database storage
   - Analysis and querying
   - Context building for LLM prompts

## Future Development

- Integration with CozoDB for graph database storage
- Support for incremental parsing and updates
- Enhanced relationship tracking between code elements
- Performance optimizations for large codebases

### Notes regarding active refactor: Module Path Representation
See plans to refactor visibility resolution and module path representation:
- Phase 1: [Module Path] (complete)
- Phase 2: [Use Statements] (complete)
- Phase 3: [Visibility Integration] (80% complete, needs more tests/cleanup)
- Phase 4: File Path Resolution (requires design)
- Phase 5: Unified Module Path Representation (requires design, see [design docs])

[Module Path]:ploke/docs/plans/visibility_resolution/phase1_module_path.md
[Use Statements]:ploke/docs/plans/visibility_resolution/phase2_use_statements.md
[Visibility Integration]:ploke/docs/plans/visibility_resolution/phase3_visibility_integration.md
[design docs]:ploke/docs/plans/visibility_resolution/module_path_repr.md
<!-- [File Path Resolution]: -->
<!-- [Unified Module Path Representation]: -->
