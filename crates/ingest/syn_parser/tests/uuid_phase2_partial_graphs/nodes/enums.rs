//! Tests for `EnumNode` parsing and field extraction.
//!
//! ## Test Coverage Analysis
//!
//! *   **Fixture:** `tests/fixture_crates/fixture_nodes/src/enums.rs`
//! *   **Tests:** `crates/ingest/syn_parser/tests/uuid_phase2_partial_graphs/nodes/enums.rs` (using `paranoid_test_fields_and_values!`)
//!
//! ### 1. Coverage of Fixture Items:
//!
//! The `EXPECTED_ENUMS_DATA` and `EXPECTED_ENUMS_ARGS` maps cover the following enums from the fixture:
//!
//! *   **Basic Enums:**
//!     *   `SampleEnum1`: Simple public enum with unit variants.
//!     *   `EnumWithData`: Public enum with tuple variants.
//!     *   `DocumentedEnum`: Public enum with a doc comment.
//!     *   `SampleEnum`: Public enum with struct-like variants.
//! *   **Visibility:**
//!     *   `PrivateEnum`: Enum with default (private) visibility.
//!     *   `CrateEnum`: Enum with `pub(crate)` visibility.
//! *   **Generics:**
//!     *   `GenericEnum<'a, T: Default + Clone, const N: usize> where T: Send`: (Currently not tested due to cfg/feature complexity in test setup) Public enum with lifetime, type, and const generic parameters, plus a `where` clause. Includes a variant with a doc comment and another with a `#[cfg]` attribute.
//! *   **Attributes & Discriminants:**
//!     *   `EnumWithAttributesAndDiscriminants`: Public enum with `#[repr(u16)]` and explicit/implicit discriminants. Includes a variant with an attribute and another with a doc comment.
//! *   **CFG Attributes:**
//!     *   `CfgEnum`: (Currently not tested due to cfg/feature complexity in test setup) Public enum conditionally compiled with `#[cfg(feature = "enum_main_feature")]`. Includes a variant also conditionally compiled.
//! *   **Mixed Variants:**
//!     *   `EnumWithMixedVariants`: Public enum with simple, multi-field tuple, and multi-field struct variants. Includes a variant with a doc comment and a field with a `#[cfg]` attribute.
//! *   **Isolated Generic Property Tests:**
//!     *   `JustTypeGeneric<A, B>`: Tests type generics.
//!     *   `JustLifetimeGeneric<'x, 'y>`: Tests lifetime generics.
//!     *   `JustConstGeneric<const X: usize, const Y: usize>`: Tests const generics.
//!     *   `JustWhereClause<T> where T: Copy`: Tests a simple `where` clause.
//! *   **Isolated Complex Field Tests:**
//!     *   `OnlyTupleVariants`: Tests multi-field tuple variants.
//!     *   `OnlyStructVariants`: Tests multi-field struct variants.
//!
//! **Conclusion for Fixture Coverage:** Good. The expanded fixture and corresponding test data cover a diverse range of enum definitions, though tests for enums with complex `cfg` interactions are currently disabled.
//!
//! ### 2. Coverage of `EnumNode` Property Variations (via `ExpectedEnumNode`):
//!
//! Based on the items covered by `paranoid_test_fields_and_values!`:
//!
//! *   `name: &'static str`: Excellent coverage.
//! *   `visibility: VisibilityKind`: Excellent coverage (`Public`, `Inherited` for private, `Crate`).
//! *   `variants_count: usize`: Excellent coverage (various counts).
//! *   `generic_params_count: usize`: Excellent coverage (0 and multiple, including mixed types).
//!     *   Note: The `GenericEnum` and `CfgEnum` tests, which have more complex `cfg` interactions affecting these counts, are currently disabled.
//! *   `attributes: Vec<Attribute>`: Good coverage (no attributes, `#[derive(...)]`, `#[repr(...)]`).
//! *   `docstring: Option<&'static str>`: Excellent coverage (`Some` and `None`).
//! *   `tracking_hash_check: bool`: Excellent coverage (all `true`).
//! *   `cfgs: Vec<String>`: Fair coverage (enum-level `#[cfg(...)]`).
//!     *   Note: The `CfgEnum` test, which specifically targets enum-level `cfg`, is currently disabled.
//!
//! **Conclusion for Property Variation Coverage (via `ExpectedEnumNode`):**
//! Most high-level `EnumNode` fields checked by `ExpectedEnumNode` have good to excellent coverage for the enabled tests. Tests for items with complex conditional compilation are currently disabled.
//!
//! ### 3. Limitations and Areas Not Fully Validated by `ExpectedEnumNode`:
//!
//! The `ExpectedEnumNode` struct and its associated `check_all_fields` method (generated by `derive(ExpectedData)`)
//! currently focus on high-level properties of the `EnumNode`. Detailed validation of nested structures
//! within an enum is limited:
//!
//! *   **`EnumNode.variants: Vec<VariantNode>`:**
//!     *   Only `variants_count` is checked.
//!     *   **Not Checked:**
//!         *   Names of individual variants.
//!         *   Specific fields within each variant (`VariantNode.fields: Vec<FieldNode>`). This includes field names, types, visibilities, and attributes of fields within tuple or struct-like variants.
//!         *   Discriminant values (`VariantNode.discriminant: Option<String>`).
//!         *   Attributes on individual variants (`VariantNode.attributes: Vec<Attribute>`).
//!         *   Docstrings on individual variants.
//!         *   CFG attributes on individual variants (`VariantNode.cfgs: Vec<String>`).
//! *   **`EnumNode.generic_params: Vec<GenericParamNode>`:**
//!     *   Only `generic_params_count` is checked.
//!     *   **Not Checked:**
//!         *   Names of generic parameters.
//!         *   Kinds of generic parameters (type, lifetime, const).
//!         *   Bounds or default values for generic parameters.
//!         *   `where` clause predicates associated with the enum.
//!
//! ### 4. Future Work for Deeper Validation:
//!
//! To achieve more comprehensive validation, the following could be considered:
//!
//! *   **Enhance `ExpectedData` Derive Macro:**
//!     *   Extend the macro to generate more detailed `ExpectedVariantNode` and `ExpectedFieldNode`
//!         structs and their checking logic if `EnumNode.variants` or `VariantNode.fields` are encountered.
//!     *   Add support for checking `Option<String>` fields that represent expressions (like discriminants)
//!         more precisely if needed, beyond simple string comparison.
//! *   **Manual Assertions (If Necessary):** For highly complex or specific checks not easily covered by
//!     the macro, targeted manual assertions could be added within the `paranoid_test_fields_and_values!`
//!     generated test functions (though this deviates from the pure macro-driven approach).
//! *   **Relation Checks:** While the macro checks `Contains` from the parent module, more specific
//!     relations like `EnumVariant` (EnumNode -> VariantNode) or `VariantField` (VariantNode -> FieldNode)
//!     are not currently asserted by this macro. These were previously covered by manual tests.
//!
//! Despite these limitations, the current macro-driven approach provides a solid baseline for
//! ensuring the correct parsing of `EnumNode`'s primary characteristics and identifying them correctly.

#![cfg(test)]
use crate::common::ParanoidArgs;
use lazy_static::lazy_static;
use ploke_core::ItemKind;
use ploke_core::{TypeId, TypeKind}; // TypeKind currently unused but kept for consistency
use std::collections::HashMap;
use syn_parser::parser::nodes::{AnyNodeId, AsAnyNodeId, Attribute, ExpectedEnumNode, GraphNode};
use syn_parser::parser::types::VisibilityKind;
use syn_parser::TestIds; // For new_test on ID types

// macro-related imports
use crate::paranoid_test_fields_and_values;
use syn_parser::parser::graph::GraphAccess;
use syn_parser::parser::nodes::PrimaryNodeIdTrait;

pub const LOG_TEST_ENUM: &str = "log_test_enum";
//
// KNOWN LIMITATIONS
// NOTE: We don't handle 'where' clauses yet.
// paranoid_test_fields_and_values!(
//     test_generic_enum_fields_and_values,
//     "crate::enums::GenericEnum",
//     EXPECTED_ENUMS_ARGS,
//     EXPECTED_ENUMS_DATA,
//     syn_parser::parser::nodes::EnumNode,
//     syn_parser::parser::nodes::ExpectedEnumNode,
//     as_enum,
//     LOG_TEST_ENUM
// );
//
// // ExpectedEnumNode for test_generic_enum_fields_and_values
// m.insert(
//     "crate::enums::GenericEnum", // Assuming feature "enum_feature_one" is NOT active by default for tests
//     ExpectedEnumNode {
//         name: "GenericEnum",
//         visibility: VisibilityKind::Public,
//         variants_count: 3, // GenericVariant, LifetimeVariant, ConstGenericVariant (ConditionalGeneric is cfg'd out)
//         // NOTE: Actual number of variants might change if 'enum_feature_one' is active during test.
//         // The test logic for cfgs on variants is not yet part of ExpectedEnumNode.
//         generic_params_count: 3, // 'a, T, N
//         // NOTE: Details of generic_params (names, bounds, kinds, where clauses) are not checked.
//         attributes: vec![Attribute {
//             name: "derive".to_string(),
//             args: vec!["Debug".to_string(), "Clone".to_string()],
//             value: None,
//         }],
//         docstring: Some("Enum with lifetime, type, and const generic parameters, and a where clause."),
//         tracking_hash_check: true,
//         cfgs: vec![], // No enum-level cfgs
//     },
// );
//
// // ParanoidArgs for test_generic_enum_fields_and_values
// m.insert(
//     "crate::enums::GenericEnum",
//     ParanoidArgs {
//         fixture: "fixture_nodes",
//         relative_file_path: "src/enums.rs",
//         ident: "GenericEnum",
//         expected_path: &["crate", "enums"],
//         item_kind: ItemKind::Enum,
//         expected_cfg: None, // The enum itself is not cfg'd, only one of its variants
//     },
// );
//
//
//
// NOTE: We aren't handling conditional compilation selection yet.
// paranoid_test_fields_and_values!(
//     test_cfg_enum_fields_and_values,
//     "crate::enums::CfgEnum",
//     EXPECTED_ENUMS_ARGS,
//     EXPECTED_ENUMS_DATA,
//     syn_parser::parser::nodes::EnumNode,
//     syn_parser::parser::nodes::ExpectedEnumNode,
//     as_enum,
//     LOG_TEST_ENUM
// );
//
// m.insert(
//     "crate::enums::CfgEnum", // Assuming feature "enum_main_feature" is NOT active by default for tests
//     ExpectedEnumNode {
//         name: "CfgEnum",
//         visibility: VisibilityKind::Public,
//         variants_count: 0, // If 'enum_main_feature' is off, the enum itself is gone.
//                            // If 'enum_main_feature' is on, then:
//                            // variants_count would be 1 (AlwaysPresent) if 'enum_variant_feature' is off,
//                            // or 2 (AlwaysPresent, SometimesPresent) if 'enum_variant_feature' is on.
//                            // This highlights the complexity of testing cfg'd items without feature control.
//                            // For now, we assume the item is NOT present if its top-level cfg is off.
//         generic_params_count: 0,
//         attributes: vec![],
//         docstring: Some("Enum that is conditionally compiled."), // Docstring is on the item regardless of cfg for parsing
//         tracking_hash_check: true, // Tracking hash is based on the item as if it exists
//         cfgs: vec!["feature = \"enum_main_feature\"".to_string()], // The cfg itself
//     },
// );
//
// m.insert(
//     "crate::enums::CfgEnum",
//     ParanoidArgs {
//         fixture: "fixture_nodes",
//         relative_file_path: "src/enums.rs",
//         ident: "CfgEnum",
//         expected_path: &["crate", "enums"],
//         item_kind: ItemKind::Enum,
//         expected_cfg: Some(&["feature = \"enum_main_feature\""]),
//     },
// );
//
//

lazy_static! {
    static ref EXPECTED_ENUMS_DATA: HashMap<&'static str, ExpectedEnumNode> = {
        let mut m = HashMap::new();
        m.insert(
            "crate::enums::SampleEnum",
            ExpectedEnumNode {
                name: "SampleEnum",
                visibility: VisibilityKind::Public,
                variants_count: 3,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("An enum demonstrating struct-like variants."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::SampleEnum1",
            ExpectedEnumNode {
                name: "SampleEnum1",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("A simple public enum with unit-like variants."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::EnumWithData",
            ExpectedEnumNode {
                name: "EnumWithData",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("An enum demonstrating variants with unnamed (tuple) data."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::DocumentedEnum",
            ExpectedEnumNode {
                name: "DocumentedEnum",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("An enum with a doc comment.\nThis is a documented enum"),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        // --- New Enums ---
        m.insert(
            "crate::enums::PrivateEnum",
            ExpectedEnumNode {
                name: "PrivateEnum",
                visibility: VisibilityKind::Inherited, // Default visibility
                variants_count: 1,
                generic_params_count: 0,
                attributes: vec![],
                docstring: None,
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::CrateEnum",
            ExpectedEnumNode {
                name: "CrateEnum",
                visibility: VisibilityKind::Crate,
                variants_count: 1,
                generic_params_count: 0,
                attributes: vec![],
                docstring: None,
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::EnumWithAttributesAndDiscriminants",
            ExpectedEnumNode {
                name: "EnumWithAttributesAndDiscriminants",
                visibility: VisibilityKind::Public,
                variants_count: 4,
                // NOTE: Discriminant values (e.g., Up = 1) are not checked by ExpectedEnumNode.
                // NOTE: Attributes on variants (e.g., #[allow(dead_code)] on Down) are not checked.
                // NOTE: Doc comments on variants are not checked.
                generic_params_count: 0,
                attributes: vec![Attribute {
                    name: "repr".to_string(),
                    args: vec!["u16".to_string()],
                    value: None,
                }],
                docstring: Some("Enum with `#[repr]` attribute and explicit discriminants."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::EnumWithMixedVariants",
            ExpectedEnumNode {
                name: "EnumWithMixedVariants",
                visibility: VisibilityKind::Public,
                variants_count: 4,
                // NOTE: Specific fields within variants (tuple or struct-like) are not checked.
                // NOTE: CFG attributes on fields within variants are not checked.
                // NOTE: Doc comments on variants are not checked.
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("Enum with various variant kinds for detailed field parsing (though not fully checked by ExpectedEnumNode yet)."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        // --- New Enums for Isolated Generic Property Testing ---
        m.insert(
            "crate::enums::JustTypeGeneric",
            ExpectedEnumNode {
                name: "JustTypeGeneric",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 2,
                attributes: vec![],
                docstring: Some("Enum solely for testing type generics."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::JustLifetimeGeneric",
            ExpectedEnumNode {
                name: "JustLifetimeGeneric",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 2,
                attributes: vec![],
                docstring: Some("Enum solely for testing lifetime generics."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::JustConstGeneric",
            ExpectedEnumNode {
                name: "JustConstGeneric",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 2,
                attributes: vec![],
                docstring: Some("Enum solely for testing const generics."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::JustWhereClause",
            ExpectedEnumNode {
                name: "JustWhereClause",
                visibility: VisibilityKind::Public,
                variants_count: 1,
                generic_params_count: 1, // NOTE: Where clause details are not checked by ExpectedEnumNode
                attributes: vec![],
                docstring: Some("Enum solely for testing a simple where clause."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        // --- New Enums for Isolated Complex Field Testing ---
        m.insert(
            "crate::enums::OnlyTupleVariants",
            ExpectedEnumNode {
                name: "OnlyTupleVariants",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("Enum solely for testing multi-field tuple variants."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::OnlyStructVariants",
            ExpectedEnumNode {
                name: "OnlyStructVariants",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("Enum solely for testing multi-field struct variants."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m
    };
}

lazy_static! {
    static ref EXPECTED_ENUMS_ARGS: HashMap<&'static str, ParanoidArgs<'static>> = {
        let mut m = HashMap::new();
        m.insert(
            "crate::enums::SampleEnum",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "SampleEnum",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::SampleEnum1",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "SampleEnum1",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::EnumWithData",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "EnumWithData",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::DocumentedEnum",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "DocumentedEnum",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        // --- New Enums ---
        m.insert(
            "crate::enums::PrivateEnum",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "PrivateEnum",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::CrateEnum",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "CrateEnum",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::EnumWithAttributesAndDiscriminants",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "EnumWithAttributesAndDiscriminants",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::EnumWithMixedVariants",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "EnumWithMixedVariants",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        // --- New Enums for Isolated Generic Property Testing ---
        m.insert(
            "crate::enums::JustTypeGeneric",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "JustTypeGeneric",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::JustLifetimeGeneric",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "JustLifetimeGeneric",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::JustConstGeneric",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "JustConstGeneric",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::JustWhereClause",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "JustWhereClause",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        // --- New Enums for Isolated Complex Field Testing ---
        m.insert(
            "crate::enums::OnlyTupleVariants",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "OnlyTupleVariants",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::OnlyStructVariants",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "OnlyStructVariants",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m
    };
}

paranoid_test_fields_and_values!(
    test_sample_enum_fields_and_values,
    "crate::enums::SampleEnum",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_sample_enum1_fields_and_values,
    "crate::enums::SampleEnum1",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_enum_with_data_fields_and_values,
    "crate::enums::EnumWithData",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_documented_enum_fields_and_values,
    "crate::enums::DocumentedEnum",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

// --- New Tests ---
paranoid_test_fields_and_values!(
    test_private_enum_fields_and_values,
    "crate::enums::PrivateEnum",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_crate_enum_fields_and_values,
    "crate::enums::CrateEnum",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_enum_with_attributes_and_discriminants_fields_and_values,
    "crate::enums::EnumWithAttributesAndDiscriminants",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_enum_with_mixed_variants_fields_and_values,
    "crate::enums::EnumWithMixedVariants",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

// --- Tests for New Enums for Isolated Generic Property Testing ---
paranoid_test_fields_and_values!(
    test_just_type_generic_fields_and_values,
    "crate::enums::JustTypeGeneric",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_just_lifetime_generic_fields_and_values,
    "crate::enums::JustLifetimeGeneric",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_just_const_generic_fields_and_values,
    "crate::enums::JustConstGeneric",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_just_where_clause_fields_and_values,
    "crate::enums::JustWhereClause",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

// --- Tests for New Enums for Isolated Complex Field Testing ---
paranoid_test_fields_and_values!(
    test_only_tuple_variants_fields_and_values,
    "crate::enums::OnlyTupleVariants",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_only_struct_variants_fields_and_values,
    "crate::enums::OnlyStructVariants",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

// --- Old Test Cases (to be removed/refactored later) ---

#[test]
#[cfg(not(feature = "type_bearing_ids"))]
fn test_enum_node_sample_enum_paranoid() {
    // This test is kept as a placeholder and will be removed once the
    // paranoid_test_fields_and_values macro covers all necessary checks,
    // or if specific relation/variant field checks need to be done manually.
    // For now, it's gated by `not(feature = "type_bearing_ids")` to avoid
    // running with the new macro-based tests.
}

#[test]
#[cfg(not(feature = "type_bearing_ids"))]
fn test_other_enum_nodes() {
    // This test is also a placeholder for similar reasons as above.
}

// To run tests with debug logging for enums:
// RUST_LOG=log_test_node,log_test_enum,test_id_regen=debug cargo test -p syn_parser enums -- --test-threads=1
// e.g., for only the target "crate::enums::GenericEnum"
// RUST_LOG=log_test_node,log_test_enum,test_id_regen=debug cargo test -p syn_parser enums::test_generic_enum_fields_and_values -- --test-threads=1

// --- Old Test Cases (to be removed/refactored later) ---

#[test]
#[cfg(not(feature = "type_bearing_ids"))]
fn test_enum_node_sample_enum_paranoid() {
    let fixture_name = "fixture_nodes";
    let results: Vec<_> = run_phase1_phase2(fixture_name)
        .into_iter()
        .map(|res| res.expect("Parsing failed")) // Collect successful parses
        .collect();

    let enum_name = "SampleEnum";
    let relative_file_path = "src/enums.rs";
    // Module path *within enums.rs* during Phase 2 parse is just ["crate"]
    let module_path = vec!["crate".to_string(), "enums".to_string()];

    let enum_node = find_enum_node_paranoid(
        &results,
        fixture_name,
        relative_file_path,
        &module_path,
        enum_name,
    );

    // --- Assertions ---
    let graph = &results // Need graph for type/relation lookups
        .iter()
        .find(|data| data.file_path.ends_with(relative_file_path))
        .unwrap()
        .graph;

    // We're working on updating these test files, and I want to try using rustacean's structural
    // search and replace. Can you provide an example that might work for:
    // Basic EnumNode Properties
    assert!(matches!(enum_node.enum_id().as_any(), AnyNodeId::Enum(_)));
    assert!(
        enum_node.tracking_hash.is_some(),
        "Tracking hash should be present"
    );
    assert_eq!(enum_node.name(), enum_name);
    assert_eq!(*enum_node.visibility(), VisibilityKind::Public);
    assert!(enum_node.attributes.is_empty());
    assert!(enum_node.docstring.is_none());
    assert!(enum_node.generic_params.is_empty());

    // Variants
    assert_eq!(enum_node.variants.len(), 3);

    // Variant 1: Variant1
    let variant1 = enum_node
        .variants
        .iter()
        .find(|v| v.name == "Variant1")
        .expect("Variant1 not found");
    assert!(matches!(variant1.id.base_tid(), NodeId::Synthetic(_)));
    assert!(variant1.fields.is_empty());
    assert!(variant1.discriminant.is_none());
    assert!(variant1.attributes.is_empty());

    // Variant 2: Variant2 { value: i32 }
    let variant2 = enum_node
        .variants
        .iter()
        .find(|v| v.name == "Variant2")
        .expect("Variant2 not found");
    assert!(matches!(variant2.id.base_tid(), NodeId::Synthetic(_)));
    assert!(variant2.discriminant.is_none());
    assert!(variant2.attributes.is_empty());
    assert_eq!(variant2.fields.len(), 1);

    // Field within Variant2: value: i32
    let field_value = &variant2.fields[0];
    assert!(matches!(field_value.id.base_tid(), NodeId::Synthetic(_)));
    assert_eq!(field_value.name.as_deref(), Some("value"));
    // Visibility of fields in struct-like variants defaults to Inherited
    assert_eq!(field_value.visibility, VisibilityKind::Inherited);
    assert!(field_value.attributes.is_empty());
    assert!(matches!(field_value.type_id, TypeId::Synthetic(_)));
    let field_type_node = find_type_node(graph, field_value.type_id);
    assert!(matches!(&field_type_node.kind, TypeKind::Named { path, .. } if path == &["i32"]));

    // Variant 3: Variant3
    let variant3 = enum_node
        .variants
        .iter()
        .find(|v| v.name == "Variant3")
        .expect("Variant3 not found");
    assert!(matches!(variant3.id.base_tid(), NodeId::Synthetic(_)));
    assert!(variant3.fields.is_empty());
    assert!(variant3.discriminant.is_none());
    assert!(variant3.attributes.is_empty());

    // --- Paranoid Relation Checks ---
    let module_id = find_inline_module_by_path(graph, &module_path)
        .expect("Failed to find module node for relation check")
        .id;

    // 1. Module Contains Enum
    assert_relation_exists(
        graph,
        GraphId::Node(module_id),
        GraphId::Node(enum_node.id),
        RelationKind::Contains,
        "Expected ModuleNode to Contain EnumNode",
    );

    // 2. Enum Contains Variants
    assert_relation_exists(
        graph,
        GraphId::Node(enum_node.id),
        GraphId::Node(variant1.id),
        RelationKind::EnumVariant,
        "Expected EnumNode to have EnumVariant relation to Variant1",
    );
    assert_relation_exists(
        graph,
        GraphId::Node(enum_node.id),
        GraphId::Node(variant2.id),
        RelationKind::EnumVariant,
        "Expected EnumNode to have EnumVariant relation to Variant2",
    );
    assert_relation_exists(
        graph,
        GraphId::Node(enum_node.id),
        GraphId::Node(variant3.id),
        RelationKind::EnumVariant,
        "Expected EnumNode to have EnumVariant relation to Variant3",
    );

    // 3. Variant Contains Field (for struct-like variants)
    assert_relation_exists(
        graph,
        GraphId::Node(variant2.id),
        GraphId::Node(field_value.id),
        RelationKind::VariantField, // Use the correct RelationKind
        "Expected Variant2 to have VariantField relation to its field 'value'",
    );

    // 4. Field Type Relation (Implicit via FieldNode.type_id)
    // Already checked via find_type_node above.
}

#[test]
#[cfg(not(feature = "type_bearing_ids"))]
fn test_other_enum_nodes() {
    let fixture_name = "fixture_nodes";
    let results: Vec<_> = run_phase1_phase2(fixture_name)
        .into_iter()
        .map(|res| res.expect("Parsing failed")) // Collect successful parses
        .collect();

    let relative_file_path = "src/enums.rs";
    let module_path = vec!["crate".to_string(), "enums".to_string()];

    // --- Find the relevant graph ---
    let graph = &results
        .iter()
        .find(|data| data.file_path.ends_with(relative_file_path))
        .expect("ParsedCodeGraph for enums.rs not found")
        .graph;

    // --- Test SampleEnum1 ---
    let enum1_name = "SampleEnum1";
    let enum1_node = find_enum_node_paranoid(
        &results,
        fixture_name,
        relative_file_path,
        &module_path,
        enum1_name,
    );

    // Assertions for SampleEnum1
    assert!(matches!(enum1_node.id, NodeId::Synthetic(_)));
    assert!(enum1_node.tracking_hash.is_some());
    assert_eq!(enum1_node.name(), enum1_name);
    assert_eq!(enum1_node.visibility(), VisibilityKind::Public);
    assert!(enum1_node.attributes.is_empty());
    assert!(enum1_node.docstring.is_none());
    assert!(enum1_node.generic_params.is_empty());
    assert_eq!(enum1_node.variants.len(), 2);

    let variant1_1 = enum1_node
        .variants
        .iter()
        .find(|v| v.name == "Variant1")
        .expect("Variant1 not found in SampleEnum1");
    let variant1_2 = enum1_node
        .variants
        .iter()
        .find(|v| v.name == "Variant2")
        .expect("Variant2 not found in SampleEnum1");
    assert!(variant1_1.fields.is_empty());
    assert!(variant1_2.fields.is_empty());

    // Relations for SampleEnum1
    let module_id = find_inline_module_by_path(graph, &module_path).unwrap().id;
    assert_relation_exists(
        graph,
        GraphId::Node(module_id),
        GraphId::Node(enum1_node.id),
        RelationKind::Contains,
        "Module->SampleEnum1",
    );
    assert_relation_exists(
        graph,
        GraphId::Node(enum1_node.id),
        GraphId::Node(variant1_1.id),
        RelationKind::EnumVariant,
        "SampleEnum1->Variant1",
    );
    assert_relation_exists(
        graph,
        GraphId::Node(enum1_node.id),
        GraphId::Node(variant1_2.id),
        RelationKind::EnumVariant,
        "SampleEnum1->Variant2",
    );

    // --- Test EnumWithData ---
    let enum_data_name = "EnumWithData";
    let enum_data_node = find_enum_node_paranoid(
        &results,
        fixture_name,
        relative_file_path,
        &module_path,
        enum_data_name,
    );

    // Assertions for EnumWithData
    assert!(matches!(enum_data_node.id, NodeId::Synthetic(_)));
    assert!(enum_data_node.tracking_hash.is_some());
    assert_eq!(enum_data_node.name(), enum_data_name);
    assert_eq!(enum_data_node.visibility(), VisibilityKind::Public);
    assert!(enum_data_node.attributes.is_empty());
    assert!(enum_data_node.docstring.is_none());
    assert!(enum_data_node.generic_params.is_empty());
    assert_eq!(enum_data_node.variants.len(), 2);

    // Variant1(i32)
    let variant_data_1 = enum_data_node
        .variants
        .iter()
        .find(|v| v.name == "Variant1")
        .expect("Variant1 not found in EnumWithData");
    assert_eq!(variant_data_1.fields.len(), 1);
    let field_data_1 = &variant_data_1.fields[0];
    assert!(field_data_1.name.is_none()); // Tuple variant field
    assert_eq!(field_data_1.visibility, VisibilityKind::Inherited);
    let field_type_node_1 = find_type_node(graph, field_data_1.type_id);
    assert!(matches!(&field_type_node_1.kind, TypeKind::Named { path, .. } if path == &["i32"]));

    // Variant2(String)
    let variant_data_2 = enum_data_node
        .variants
        .iter()
        .find(|v| v.name == "Variant2")
        .expect("Variant2 not found in EnumWithData");
    assert_eq!(variant_data_2.fields.len(), 1);
    let field_data_2 = &variant_data_2.fields[0];
    assert!(field_data_2.name.is_none()); // Tuple variant field
    assert_eq!(field_data_2.visibility, VisibilityKind::Inherited);
    let field_type_node_2 = find_type_node(graph, field_data_2.type_id);
    assert!(matches!(&field_type_node_2.kind, TypeKind::Named { path, .. } if path == &["String"]));

    // Relations for EnumWithData
    assert_relation_exists(
        graph,
        GraphId::Node(module_id),
        GraphId::Node(enum_data_node.id),
        RelationKind::Contains,
        "Module->EnumWithData",
    );
    assert_relation_exists(
        graph,
        GraphId::Node(enum_data_node.id),
        GraphId::Node(variant_data_1.id),
        RelationKind::EnumVariant,
        "EnumWithData->Variant1",
    );
    assert_relation_exists(
        graph,
        GraphId::Node(enum_data_node.id),
        GraphId::Node(variant_data_2.id),
        RelationKind::EnumVariant,
        "EnumWithData->Variant2",
    );
    assert_relation_exists(
        graph,
        GraphId::Node(variant_data_1.id),
        GraphId::Node(field_data_1.id),
        RelationKind::VariantField,
        "EnumWithData::Variant1->Field0",
    );
    assert_relation_exists(
        graph,
        GraphId::Node(variant_data_2.id),
        GraphId::Node(field_data_2.id),
        RelationKind::VariantField,
        "EnumWithData::Variant2->Field0",
    );

    // --- Test DocumentedEnum ---
    let enum_doc_name = "DocumentedEnum";
    let enum_doc_node = find_enum_node_paranoid(
        &results,
        fixture_name,
        relative_file_path,
        &module_path,
        enum_doc_name,
    );

    // Assertions for DocumentedEnum
    assert!(matches!(enum_doc_node.id, NodeId::Synthetic(_)));
    assert!(enum_doc_node.tracking_hash.is_some());
    assert_eq!(enum_doc_node.name(), enum_doc_name);
    assert_eq!(enum_doc_node.visibility(), VisibilityKind::Public);
    assert!(enum_doc_node.attributes.is_empty());
    assert!(enum_doc_node.generic_params.is_empty());
    assert_eq!(enum_doc_node.variants.len(), 2);

    // Docstring
    assert!(enum_doc_node.docstring.is_some());
    assert_eq!(
        enum_doc_node.docstring.as_deref(),
        Some("This is a documented enum") // Note leading space
    );

    let variant_doc_1 = enum_doc_node
        .variants
        .iter()
        .find(|v| v.name == "Variant1")
        .expect("Variant1 not found in DocumentedEnum");
    let variant_doc_2 = enum_doc_node
        .variants
        .iter()
        .find(|v| v.name == "Variant2")
        .expect("Variant2 not found in DocumentedEnum");
    assert!(variant_doc_1.fields.is_empty());
    assert!(variant_doc_2.fields.is_empty());

    // Relations for DocumentedEnum
    assert_relation_exists(
        graph,
        GraphId::Node(module_id),
        GraphId::Node(enum_doc_node.id),
        RelationKind::Contains,
        "Module->DocumentedEnum",
    );
    assert_relation_exists(
        graph,
        GraphId::Node(enum_doc_node.id),
        GraphId::Node(variant_doc_1.id),
        RelationKind::EnumVariant,
        "DocumentedEnum->Variant1",
    );
    assert_relation_exists(
        graph,
        GraphId::Node(enum_doc_node.id),
        GraphId::Node(variant_doc_2.id),
        RelationKind::EnumVariant,
        "DocumentedEnum->Variant2",
    );
}
