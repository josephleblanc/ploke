//! Tests for `EnumNode` parsing and field extraction.
//!
//! ## Test Coverage Analysis
//!
//! *   **Fixture:** `tests/fixture_crates/fixture_nodes/src/enums.rs`
//! *   **Tests:** `crates/ingest/syn_parser/tests/uuid_phase2_partial_graphs/nodes/enums.rs` (using `paranoid_test_fields_and_values!`)
//!
//! ### 1. Coverage of Fixture Items:
//!
//! The `EXPECTED_ENUMS_DATA` and `EXPECTED_ENUMS_ARGS` maps cover the following enums from the fixture:
//!
//! *   **Basic Enums:**
//!     *   `SampleEnum1`: Simple public enum with unit variants.
//!     *   `EnumWithData`: Public enum with tuple variants.
//!     *   `DocumentedEnum`: Public enum with a doc comment.
//!     *   `SampleEnum`: Public enum with struct-like variants.
//! *   **Visibility:**
//!     *   `PrivateEnum`: Enum with default (private) visibility.
//!     *   `CrateEnum`: Enum with `pub(crate)` visibility.
//! *   **Generics:**
//!     *   `GenericEnum<'a, T: Default + Clone, const N: usize> where T: Send`: (Currently not tested due to cfg/feature complexity in test setup) Public enum with lifetime, type, and const generic parameters, plus a `where` clause. Includes a variant with a doc comment and another with a `#[cfg]` attribute.
//! *   **Attributes & Discriminants:**
//!     *   `EnumWithAttributesAndDiscriminants`: Public enum with `#[repr(u16)]` and explicit/implicit discriminants. Includes a variant with an attribute and another with a doc comment.
//! *   **CFG Attributes:**
//!     *   `CfgEnum`: (Currently not tested due to cfg/feature complexity in test setup) Public enum conditionally compiled with `#[cfg(feature = "enum_main_feature")]`. Includes a variant also conditionally compiled.
//! *   **Mixed Variants:**
//!     *   `EnumWithMixedVariants`: Public enum with simple, multi-field tuple, and multi-field struct variants. Includes a variant with a doc comment and a field with a `#[cfg]` attribute.
//! *   **Isolated Generic Property Tests:**
//!     *   `JustTypeGeneric<A, B>`: Tests type generics.
//!     *   `JustLifetimeGeneric<'x, 'y>`: Tests lifetime generics.
//!     *   `JustConstGeneric<const X: usize, const Y: usize>`: Tests const generics.
//!     *   `JustWhereClause<T> where T: Copy`: Tests a simple `where` clause.
//! *   **Isolated Complex Field Tests:**
//!     *   `OnlyTupleVariants`: Tests multi-field tuple variants.
//!     *   `OnlyStructVariants`: Tests multi-field struct variants.
//!
//! **Conclusion for Fixture Coverage:** Good. The expanded fixture and corresponding test data cover a diverse range of enum definitions, though tests for enums with complex `cfg` interactions are currently disabled.
//!
//! ### 2. Coverage of `EnumNode` Property Variations (via `ExpectedEnumNode`):
//!
//! Based on the items covered by `paranoid_test_fields_and_values!`:
//!
//! *   `name: &'static str`: Excellent coverage.
//! *   `visibility: VisibilityKind`: Excellent coverage (`Public`, `Inherited` for private, `Crate`).
//! *   `variants_count: usize`: Excellent coverage (various counts).
//! *   `generic_params_count: usize`: Excellent coverage (0 and multiple, including mixed types).
//!     *   Note: The `GenericEnum` and `CfgEnum` tests, which have more complex `cfg` interactions affecting these counts, are currently disabled.
//! *   `attributes: Vec<Attribute>`: Good coverage (no attributes, `#[derive(...)]`, `#[repr(...)]`).
//! *   `docstring: Option<&'static str>`: Excellent coverage (`Some` and `None`).
//! *   `tracking_hash_check: bool`: Excellent coverage (all `true`).
//! *   `cfgs: Vec<String>`: Fair coverage (enum-level `#[cfg(...)]`).
//!     *   Note: The `CfgEnum` test, which specifically targets enum-level `cfg`, is currently disabled.
//!
//! **Conclusion for Property Variation Coverage (via `ExpectedEnumNode`):**
//! Most high-level `EnumNode` fields checked by `ExpectedEnumNode` have good to excellent coverage for the enabled tests. Tests for items with complex conditional compilation are currently disabled.
//!
//! ### 3. Limitations and Areas Not Fully Validated by `ExpectedEnumNode`:
//!
//! The `ExpectedEnumNode` struct and its associated `check_all_fields` method (generated by `derive(ExpectedData)`)
//! currently focus on high-level properties of the `EnumNode`. Detailed validation of nested structures
//! within an enum is limited:
//!
//! *   **`EnumNode.variants: Vec<VariantNode>`:**
//!     *   Only `variants_count` is checked.
//!     *   **Not Checked:**
//!         *   Names of individual variants.
//!         *   Specific fields within each variant (`VariantNode.fields: Vec<FieldNode>`). This includes field names, types, visibilities, and attributes of fields within tuple or struct-like variants.
//!         *   Discriminant values (`VariantNode.discriminant: Option<String>`).
//!         *   Attributes on individual variants (`VariantNode.attributes: Vec<Attribute>`).
//!         *   Docstrings on individual variants.
//!         *   CFG attributes on individual variants (`VariantNode.cfgs: Vec<String>`).
//! *   **`EnumNode.generic_params: Vec<GenericParamNode>`:**
//!     *   Only `generic_params_count` is checked.
//!     *   **Not Checked:**
//!         *   Names of generic parameters.
//!         *   Kinds of generic parameters (type, lifetime, const).
//!         *   Bounds or default values for generic parameters.
//!         *   `where` clause predicates associated with the enum.
//!
//! ### 4. Future Work for Deeper Validation:
//!
//! To achieve more comprehensive validation, the following could be considered:
//!
//! *   **Enhance `ExpectedData` Derive Macro:**
//!     *   Extend the macro to generate more detailed `ExpectedVariantNode` and `ExpectedFieldNode`
//!         structs and their checking logic if `EnumNode.variants` or `VariantNode.fields` are encountered.
//!     *   Add support for checking `Option<String>` fields that represent expressions (like discriminants)
//!         more precisely if needed, beyond simple string comparison.
//! *   **Manual Assertions (If Necessary):** For highly complex or specific checks not easily covered by
//!     the macro, targeted manual assertions could be added within the `paranoid_test_fields_and_values!`
//!     generated test functions (though this deviates from the pure macro-driven approach).
//! *   **Relation Checks:** While the macro checks `Contains` from the parent module, more specific
//!     relations like `EnumVariant` (EnumNode -> VariantNode) or `VariantField` (VariantNode -> FieldNode)
//!     are not currently asserted by this macro. These were previously covered by manual tests.
//!
//! Despite these limitations, the current macro-driven approach provides a solid baseline for
//! ensuring the correct parsing of `EnumNode`'s primary characteristics and identifying them correctly.

#![cfg(test)]
use crate::common::ParanoidArgs;
use lazy_static::lazy_static;
use ploke_core::ItemKind;
use ploke_core::{TypeId, TypeKind}; // TypeKind currently unused but kept for consistency
use std::collections::HashMap;
use syn_parser::parser::nodes::{AnyNodeId, AsAnyNodeId, Attribute, ExpectedEnumNode, GraphNode};
use syn_parser::parser::types::VisibilityKind;
use syn_parser::TestIds; // For new_test on ID types

// macro-related imports
use crate::paranoid_test_fields_and_values;
use syn_parser::parser::graph::GraphAccess;
use syn_parser::parser::nodes::PrimaryNodeIdTrait;

pub const LOG_TEST_ENUM: &str = "log_test_enum";
//
// KNOWN LIMITATIONS
// NOTE: We don't handle 'where' clauses yet.
// paranoid_test_fields_and_values!(
//     test_generic_enum_fields_and_values,
//     "crate::enums::GenericEnum",
//     EXPECTED_ENUMS_ARGS,
//     EXPECTED_ENUMS_DATA,
//     syn_parser::parser::nodes::EnumNode,
//     syn_parser::parser::nodes::ExpectedEnumNode,
//     as_enum,
//     LOG_TEST_ENUM
// );
//
// // ExpectedEnumNode for test_generic_enum_fields_and_values
// m.insert(
//     "crate::enums::GenericEnum", // Assuming feature "enum_feature_one" is NOT active by default for tests
//     ExpectedEnumNode {
//         name: "GenericEnum",
//         visibility: VisibilityKind::Public,
//         variants_count: 3, // GenericVariant, LifetimeVariant, ConstGenericVariant (ConditionalGeneric is cfg'd out)
//         // NOTE: Actual number of variants might change if 'enum_feature_one' is active during test.
//         // The test logic for cfgs on variants is not yet part of ExpectedEnumNode.
//         generic_params_count: 3, // 'a, T, N
//         // NOTE: Details of generic_params (names, bounds, kinds, where clauses) are not checked.
//         attributes: vec![Attribute {
//             name: "derive".to_string(),
//             args: vec!["Debug".to_string(), "Clone".to_string()],
//             value: None,
//         }],
//         docstring: Some("Enum with lifetime, type, and const generic parameters, and a where clause."),
//         tracking_hash_check: true,
//         cfgs: vec![], // No enum-level cfgs
//     },
// );
//
// // ParanoidArgs for test_generic_enum_fields_and_values
// m.insert(
//     "crate::enums::GenericEnum",
//     ParanoidArgs {
//         fixture: "fixture_nodes",
//         relative_file_path: "src/enums.rs",
//         ident: "GenericEnum",
//         expected_path: &["crate", "enums"],
//         item_kind: ItemKind::Enum,
//         expected_cfg: None, // The enum itself is not cfg'd, only one of its variants
//     },
// );
//
//
//
// NOTE: We aren't handling conditional compilation selection yet.
// paranoid_test_fields_and_values!(
//     test_cfg_enum_fields_and_values,
//     "crate::enums::CfgEnum",
//     EXPECTED_ENUMS_ARGS,
//     EXPECTED_ENUMS_DATA,
//     syn_parser::parser::nodes::EnumNode,
//     syn_parser::parser::nodes::ExpectedEnumNode,
//     as_enum,
//     LOG_TEST_ENUM
// );
//
// m.insert(
//     "crate::enums::CfgEnum", // Assuming feature "enum_main_feature" is NOT active by default for tests
//     ExpectedEnumNode {
//         name: "CfgEnum",
//         visibility: VisibilityKind::Public,
//         variants_count: 0, // If 'enum_main_feature' is off, the enum itself is gone.
//                            // If 'enum_main_feature' is on, then:
//                            // variants_count would be 1 (AlwaysPresent) if 'enum_variant_feature' is off,
//                            // or 2 (AlwaysPresent, SometimesPresent) if 'enum_variant_feature' is on.
//                            // This highlights the complexity of testing cfg'd items without feature control.
//                            // For now, we assume the item is NOT present if its top-level cfg is off.
//         generic_params_count: 0,
//         attributes: vec![],
//         docstring: Some("Enum that is conditionally compiled."), // Docstring is on the item regardless of cfg for parsing
//         tracking_hash_check: true, // Tracking hash is based on the item as if it exists
//         cfgs: vec!["feature = \"enum_main_feature\"".to_string()], // The cfg itself
//     },
// );
//
// m.insert(
//     "crate::enums::CfgEnum",
//     ParanoidArgs {
//         fixture: "fixture_nodes",
//         relative_file_path: "src/enums.rs",
//         ident: "CfgEnum",
//         expected_path: &["crate", "enums"],
//         item_kind: ItemKind::Enum,
//         expected_cfg: Some(&["feature = \"enum_main_feature\""]),
//     },
// );
//
//

lazy_static! {
    static ref EXPECTED_ENUMS_DATA: HashMap<&'static str, ExpectedEnumNode> = {
        let mut m = HashMap::new();
        m.insert(
            "crate::enums::SampleEnum",
            ExpectedEnumNode {
                name: "SampleEnum",
                visibility: VisibilityKind::Public,
                variants_count: 3,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("An enum demonstrating struct-like variants."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::SampleEnum1",
            ExpectedEnumNode {
                name: "SampleEnum1",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("A simple public enum with unit-like variants."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::EnumWithData",
            ExpectedEnumNode {
                name: "EnumWithData",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("An enum demonstrating variants with unnamed (tuple) data."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::DocumentedEnum",
            ExpectedEnumNode {
                name: "DocumentedEnum",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("An enum with a doc comment.\nThis is a documented enum"),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        // --- New Enums ---
        m.insert(
            "crate::enums::PrivateEnum",
            ExpectedEnumNode {
                name: "PrivateEnum",
                visibility: VisibilityKind::Inherited, // Default visibility
                variants_count: 1,
                generic_params_count: 0,
                attributes: vec![],
                docstring: None,
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::CrateEnum",
            ExpectedEnumNode {
                name: "CrateEnum",
                visibility: VisibilityKind::Crate,
                variants_count: 1,
                generic_params_count: 0,
                attributes: vec![],
                docstring: None,
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::EnumWithAttributesAndDiscriminants",
            ExpectedEnumNode {
                name: "EnumWithAttributesAndDiscriminants",
                visibility: VisibilityKind::Public,
                variants_count: 4,
                // NOTE: Discriminant values (e.g., Up = 1) are not checked by ExpectedEnumNode.
                // NOTE: Attributes on variants (e.g., #[allow(dead_code)] on Down) are not checked.
                // NOTE: Doc comments on variants are not checked.
                generic_params_count: 0,
                attributes: vec![Attribute {
                    name: "repr".to_string(),
                    args: vec!["u16".to_string()],
                    value: None,
                }],
                docstring: Some("Enum with `#[repr]` attribute and explicit discriminants."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::EnumWithMixedVariants",
            ExpectedEnumNode {
                name: "EnumWithMixedVariants",
                visibility: VisibilityKind::Public,
                variants_count: 4,
                // NOTE: Specific fields within variants (tuple or struct-like) are not checked.
                // NOTE: CFG attributes on fields within variants are not checked.
                // NOTE: Doc comments on variants are not checked.
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("Enum with various variant kinds for detailed field parsing (though not fully checked by ExpectedEnumNode yet)."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        // --- New Enums for Isolated Generic Property Testing ---
        m.insert(
            "crate::enums::JustTypeGeneric",
            ExpectedEnumNode {
                name: "JustTypeGeneric",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 2,
                attributes: vec![],
                docstring: Some("Enum solely for testing type generics."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::JustLifetimeGeneric",
            ExpectedEnumNode {
                name: "JustLifetimeGeneric",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 2,
                attributes: vec![],
                docstring: Some("Enum solely for testing lifetime generics."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::JustConstGeneric",
            ExpectedEnumNode {
                name: "JustConstGeneric",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 2,
                attributes: vec![],
                docstring: Some("Enum solely for testing const generics."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::JustWhereClause",
            ExpectedEnumNode {
                name: "JustWhereClause",
                visibility: VisibilityKind::Public,
                variants_count: 1,
                generic_params_count: 1, // NOTE: Where clause details are not checked by ExpectedEnumNode
                attributes: vec![],
                docstring: Some("Enum solely for testing a simple where clause."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        // --- New Enums for Isolated Complex Field Testing ---
        m.insert(
            "crate::enums::OnlyTupleVariants",
            ExpectedEnumNode {
                name: "OnlyTupleVariants",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("Enum solely for testing multi-field tuple variants."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m.insert(
            "crate::enums::OnlyStructVariants",
            ExpectedEnumNode {
                name: "OnlyStructVariants",
                visibility: VisibilityKind::Public,
                variants_count: 2,
                generic_params_count: 0,
                attributes: vec![],
                docstring: Some("Enum solely for testing multi-field struct variants."),
                tracking_hash_check: true,
                cfgs: vec![],
            },
        );
        m
    };
}

lazy_static! {
    static ref EXPECTED_ENUMS_ARGS: HashMap<&'static str, ParanoidArgs<'static>> = {
        let mut m = HashMap::new();
        m.insert(
            "crate::enums::SampleEnum",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "SampleEnum",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::SampleEnum1",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "SampleEnum1",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::EnumWithData",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "EnumWithData",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::DocumentedEnum",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "DocumentedEnum",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        // --- New Enums ---
        m.insert(
            "crate::enums::PrivateEnum",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "PrivateEnum",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::CrateEnum",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "CrateEnum",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::EnumWithAttributesAndDiscriminants",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "EnumWithAttributesAndDiscriminants",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::EnumWithMixedVariants",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "EnumWithMixedVariants",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        // --- New Enums for Isolated Generic Property Testing ---
        m.insert(
            "crate::enums::JustTypeGeneric",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "JustTypeGeneric",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::JustLifetimeGeneric",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "JustLifetimeGeneric",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::JustConstGeneric",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "JustConstGeneric",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::JustWhereClause",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "JustWhereClause",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        // --- New Enums for Isolated Complex Field Testing ---
        m.insert(
            "crate::enums::OnlyTupleVariants",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "OnlyTupleVariants",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m.insert(
            "crate::enums::OnlyStructVariants",
            ParanoidArgs {
                fixture: "fixture_nodes",
                relative_file_path: "src/enums.rs",
                ident: "OnlyStructVariants",
                expected_path: &["crate", "enums"],
                item_kind: ItemKind::Enum,
                expected_cfg: None,
            },
        );
        m
    };
}

paranoid_test_fields_and_values!(
    test_sample_enum_fields_and_values,
    "crate::enums::SampleEnum",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_sample_enum1_fields_and_values,
    "crate::enums::SampleEnum1",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_enum_with_data_fields_and_values,
    "crate::enums::EnumWithData",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_documented_enum_fields_and_values,
    "crate::enums::DocumentedEnum",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

// --- New Tests ---
paranoid_test_fields_and_values!(
    test_private_enum_fields_and_values,
    "crate::enums::PrivateEnum",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_crate_enum_fields_and_values,
    "crate::enums::CrateEnum",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_enum_with_attributes_and_discriminants_fields_and_values,
    "crate::enums::EnumWithAttributesAndDiscriminants",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_enum_with_mixed_variants_fields_and_values,
    "crate::enums::EnumWithMixedVariants",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

// --- Tests for New Enums for Isolated Generic Property Testing ---
paranoid_test_fields_and_values!(
    test_just_type_generic_fields_and_values,
    "crate::enums::JustTypeGeneric",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_just_lifetime_generic_fields_and_values,
    "crate::enums::JustLifetimeGeneric",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_just_const_generic_fields_and_values,
    "crate::enums::JustConstGeneric",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_just_where_clause_fields_and_values,
    "crate::enums::JustWhereClause",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

// --- Tests for New Enums for Isolated Complex Field Testing ---
paranoid_test_fields_and_values!(
    test_only_tuple_variants_fields_and_values,
    "crate::enums::OnlyTupleVariants",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);

paranoid_test_fields_and_values!(
    test_only_struct_variants_fields_and_values,
    "crate::enums::OnlyStructVariants",
    EXPECTED_ENUMS_ARGS,
    EXPECTED_ENUMS_DATA,
    syn_parser::parser::nodes::EnumNode,
    syn_parser::parser::nodes::ExpectedEnumNode,
    as_enum,
    LOG_TEST_ENUM
);
