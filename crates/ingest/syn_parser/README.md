# syn_parser

A comprehensive Rust code parser and analyzer built on the `syn` crate.

## Overview

`syn_parser` is a core component of the ploke project, responsible for parsing Rust source code into a structured graph representation. It extracts detailed information about code structure, relationships, and semantics to enable advanced code analysis and retrieval.

## Features

- **Complete Rust Syntax Support**: Parses all Rust language constructs including functions, structs, enums, traits, implementations, and modules
- **Type System Analysis**: Tracks complex type relationships, generics, and type bounds
- **Visibility Tracking**: Preserves public/private visibility information
- **Documentation Extraction**: Captures docstrings and attributes
- **Parallel Processing**: Efficiently processes multiple files concurrently using Rayon
- **Thread-safe Design**: All core data structures are Send + Sync
- **Serialization**: Exports parsed code graphs to RON format

## Architecture

The parser uses a visitor pattern to traverse the Rust AST (Abstract Syntax Tree) generated by the `syn` crate. It builds a comprehensive `CodeGraph` structure that contains:

- Functions with their signatures, parameters, and return types
- Type definitions (structs, enums, unions, type aliases)
- Trait definitions and implementations
- Module structure and visibility
- Type relationships and dependencies

## Usage

### Basic Parsing

```rust
use syn_parser::parser::visitor::analyze_code;
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let file_path = Path::new("src/main.rs");
    let code_graph = analyze_code(file_path)?;
    
    // Access parsed information
    println!("Found {} functions", code_graph.functions.len());
    println!("Found {} types", code_graph.defined_types.len());
    
    Ok(())
}
```

### Parallel Processing

```rust
use syn_parser::parser::visitor::analyze_files_parallel;
use std::path::PathBuf;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let file_paths = vec![
        PathBuf::from("src/main.rs"),
        PathBuf::from("src/lib.rs"),
    ];
    
    // Process files in parallel with 4 worker threads
    let code_graphs = analyze_files_parallel(file_paths, 4)?;
    
    println!("Processed {} files", code_graphs.len());
    Ok(())
}
```

### Serialization

```rust
use syn_parser::serialization::ron::save_to_ron;
use syn_parser::parser::visitor::analyze_code;
use std::path::Path;

fn main() -> Result<(), Box<dyn std::error::Error>> {
    let file_path = Path::new("src/main.rs");
    let code_graph = analyze_code(file_path)?;
    
    // Save to RON file
    save_to_ron(&code_graph, Path::new("output.ron"))?;
    
    Ok(())
}
```

## Integration with ploke

`syn_parser` is designed to work as part of the larger ploke system:

1. It receives file paths to parse from the file watcher or UI components
2. It processes these files and generates code graphs
3. The code graphs are then passed to other components for:
   - Embedding generation
   - Database storage
   - Analysis and querying
   - Context building for LLM prompts

## Future Development

- Integration with CozoDB for graph database storage
- Support for incremental parsing and updates
- Enhanced relationship tracking between code elements
- Performance optimizations for large codebases

