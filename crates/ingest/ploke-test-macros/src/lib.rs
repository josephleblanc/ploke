//! Procedural macros for reducing boilerplate in ploke tests.

extern crate proc_macro;

use proc_macro::TokenStream;
use proc_macro2::Span;
use proc_macro_error::{abort, proc_macro_error};
use quote::{format_ident, quote}; // Removed unused format_ident, ToTokens
use syn::{
    parse::{Parse, ParseStream},
    parse_macro_input,
    Expr,
    ItemFn,
    Lit,
    Meta,
    MetaNameValue,
    // Removed NestedMeta
    Result as SynResult,
    Token,
    // Removed unused types: AttributeArgs, FnArg, Ident, Pat, PatType, Path, Stmt, Type, Visibility
};

// Assuming ItemKind is accessible via syn_parser::ItemKind
use heck::ToPascalCase; // For generating struct names like ExpectedConstData
use ploke_core::ItemKind;
use syn::{parse_quote, spanned::Spanned, Data, DeriveInput, Field, Fields, FieldsNamed, Type}; // Added necessary syn items

// --- Base Trait (for generated Expected*Data structs) ---

// This trait will be implemented by the structs generated by the derive macro.
// It provides a common interface for the attribute macro to use.
trait ExpectedNodeData<N> {
    // Finds nodes matching the expected data by value.
    // The implementation will be generated by the derive macro.
    fn find_node_by_values<'a>(
        &'a self,
        parsed: &'a syn_parser::parser::ParsedCodeGraph, // Use qualified path
    ) -> Box<dyn Iterator<Item = &'a N> + 'a>; // Return Box<dyn Iterator>

    // Performs all generated checks and asserts they pass.
    // Returns true if all checks pass, false otherwise (and logs failures).
    // The implementation will be generated by the derive macro.
    fn check_all_fields(&self, node: &N) -> bool;

    // Optional: Add accessors for common fields if needed by the attribute macro directly
    // fn name(&self) -> &'static str;
    // fn visibility(&self) -> &syn_parser::parser::types::VisibilityKind;
    // ...
}

// --- Attribute Macro Argument Parsing ---

#[derive(Debug)]
struct ParanoidTestArgs {
    kind: ItemKind,
    ident: String,
    fixture: String,
    relative_file_path: String,
    expected_path: Vec<String>,        // Store as Vec<String> directly
    expected_cfg: Option<Vec<String>>, // Store as Option<Vec<String>>
}

impl Parse for ParanoidTestArgs {
    fn parse(input: ParseStream) -> SynResult<Self> {
        let mut kind: Option<ItemKind> = None;
        let mut ident: Option<String> = None;
        let mut fixture: Option<String> = None;
        let mut relative_file_path: Option<String> = None;
        let mut expected_path: Option<Vec<String>> = None;
        let mut expected_cfg: Option<Vec<String>> = None; // Initialize as None

        // Parse the input stream as a punctuated sequence of Meta items
        let args = syn::punctuated::Punctuated::<Meta, Token![,]>::parse_terminated(input)?;

        for arg in args {
            match arg {
                // Match directly on Meta::NameValue
                Meta::NameValue(MetaNameValue { path, value, .. }) => {
                    let key = path
                        .get_ident()
                        .ok_or_else(|| syn::Error::new_spanned(&path, "Expected identifier key"))?;
                    let key_str = key.to_string();

                    // Ensure the value is a literal expression
                    let lit = match value {
                        Expr::Lit(expr_lit) => expr_lit.lit,
                        _ => return Err(syn::Error::new_spanned(value, "Expected literal value")),
                    };

                    match key_str.as_str() {
                        "kind" => {
                            if let Lit::Str(lit_str) = &lit {
                                // Borrow lit here
                                // Map string to ItemKind variant
                                kind = match lit_str.value().as_str() {
                                    "Const" => Some(ItemKind::Const),
                                    "Static" => Some(ItemKind::Static),
                                    "Function" => Some(ItemKind::Function),
                                    "Struct" => Some(ItemKind::Struct),
                                    "Enum" => Some(ItemKind::Enum),
                                    "Union" => Some(ItemKind::Union),
                                    "TypeAlias" => Some(ItemKind::TypeAlias),
                                    "Trait" => Some(ItemKind::Trait),
                                    "Impl" => Some(ItemKind::Impl),
                                    "Module" => Some(ItemKind::Module),
                                    "Macro" => Some(ItemKind::Macro),
                                    "Import" => Some(ItemKind::Import),
                                    // Add other kinds as needed
                                    _ => {
                                        return Err(syn::Error::new_spanned(
                                            lit_str,
                                            "Unsupported ItemKind string",
                                        ))
                                    }
                                };
                            } else {
                                return Err(syn::Error::new_spanned(
                                    &lit,
                                    "Expected string literal for kind",
                                )); // Pass borrowed lit
                            }
                        }
                        "ident" => {
                            if let Lit::Str(lit_str) = &lit {
                                // Borrow lit here
                                ident = Some(lit_str.value());
                            } else {
                                return Err(syn::Error::new_spanned(
                                    &lit,
                                    "Expected string literal for ident",
                                )); // Pass borrowed lit
                            }
                        }
                        "fixture" => {
                            if let Lit::Str(lit_str) = &lit {
                                // Borrow lit here
                                fixture = Some(lit_str.value());
                            } else {
                                return Err(syn::Error::new_spanned(
                                    &lit,
                                    "Expected string literal for fixture",
                                )); // Pass borrowed lit
                            }
                        }
                        "relative_file_path" => {
                            if let Lit::Str(lit_str) = &lit {
                                // Borrow lit here
                                relative_file_path = Some(lit_str.value());
                            } else {
                                return Err(syn::Error::new_spanned(
                                    &lit,
                                    "Expected string literal for relative_file_path",
                                )); // Pass borrowed lit
                            }
                        }
                        "expected_path" => {
                            if let Lit::Str(lit_str) = &lit {
                                // Borrow lit here
                                // Assume comma-separated string like "crate,module,item"
                                expected_path =
                                    Some(lit_str.value().split(',').map(String::from).collect());
                            } else {
                                return Err(syn::Error::new_spanned(&lit, "Expected string literal for expected_path (e.g., \"crate,module\")"));
                                // Pass borrowed lit
                            }
                        }
                        "expected_cfg" => {
                            if let Lit::Str(lit_str) = &lit {
                                // Borrow lit here
                                // Assume comma-separated string like "cfg1,cfg2"
                                expected_cfg =
                                    Some(lit_str.value().split(',').map(String::from).collect());
                            } else {
                                return Err(syn::Error::new_spanned(&lit, "Expected string literal for expected_cfg (e.g., \"cfg1,cfg2\")"));
                                // Pass borrowed lit
                            }
                        }
                        _ => return Err(syn::Error::new_spanned(key, "Unknown argument name")),
                    }
                }
                // Handle other Meta types if necessary, or error out
                _ => {
                    return Err(syn::Error::new_spanned(
                        arg,
                        "Expected key = \"value\" format",
                    ))
                }
            }
        }

        // Check for missing mandatory arguments
        let kind =
            kind.ok_or_else(|| syn::Error::new(Span::call_site(), "Missing 'kind' argument"))?;
        let ident =
            ident.ok_or_else(|| syn::Error::new(Span::call_site(), "Missing 'ident' argument"))?;
        let fixture = fixture
            .ok_or_else(|| syn::Error::new(Span::call_site(), "Missing 'fixture' argument"))?;
        let relative_file_path = relative_file_path.ok_or_else(|| {
            syn::Error::new(Span::call_site(), "Missing 'relative_file_path' argument")
        })?;
        let expected_path = expected_path.ok_or_else(|| {
            syn::Error::new(Span::call_site(), "Missing 'expected_path' argument")
        })?;
        // expected_cfg is optional, defaults to None if not provided

        Ok(ParanoidTestArgs {
            kind,
            ident,
            fixture,
            relative_file_path,
            expected_path,
            expected_cfg,
        })
    }
}

#[proc_macro_error]
#[proc_macro_attribute]
pub fn paranoid_test(args: TokenStream, input: TokenStream) -> TokenStream {
    let test_fn = parse_macro_input!(input as ItemFn);
    let test_fn_name = &test_fn.sig.ident;
    let test_fn_vis = &test_fn.vis;
    let test_fn_attrs = &test_fn.attrs; // Keep original attributes like #[ignore]

    let parsed_args = parse_macro_input!(args as ParanoidTestArgs);

    // Extract values from parsed_args
    let kind_enum = parsed_args.kind; // This is ItemKind enum value
    let ident_str = parsed_args.ident;
    let fixture_str = parsed_args.fixture;
    let rel_path_str = parsed_args.relative_file_path;
    let expected_path_vec = parsed_args.expected_path;
    let expected_cfg_opt_vec = parsed_args.expected_cfg;

    // --- Mapping from ItemKind to Test Data ---
    // We need the path to the test module where Expected*Data and maps are defined.
    // This assumes the macro is invoked from within a test module inside
    // `syn_parser/tests/uuid_phase2_partial_graphs/nodes/`.
    // If invoked elsewhere, these paths need adjustment.
    let test_module_path = quote! { crate::uuid_phase2_partial_graphs::nodes::const_static }; // Adjust if needed

    // Construct the path to the ItemKind variant for quoting
    let kind_path = match kind_enum {
        ItemKind::Const => quote! { ploke_core::ItemKind::Const },
        ItemKind::Static => quote! { ploke_core::ItemKind::Static },
        ItemKind::Function => quote! { ploke_core::ItemKind::Function },
        ItemKind::Struct => quote! { ploke_core::ItemKind::Struct },
        ItemKind::Enum => quote! { ploke_core::ItemKind::Enum },
        ItemKind::Union => quote! { ploke_core::ItemKind::Union },
        ItemKind::TypeAlias => quote! { ploke_core::ItemKind::TypeAlias },
        ItemKind::Trait => quote! { ploke_core::ItemKind::Trait },
        ItemKind::Impl => quote! { ploke_core::ItemKind::Impl },
        ItemKind::Module => quote! { ploke_core::ItemKind::Module },
        ItemKind::Macro => quote! { ploke_core::ItemKind::Macro },
        ItemKind::Import => quote! { ploke_core::ItemKind::Import },
        // Add other kinds as needed
        _ => abort!(
            Span::call_site(),
            "Unsupported ItemKind for #[paranoid_test]: {:?}",
            kind_enum
        ),
    };

    // --- Attribute Macro Implementation ---

    // No changes needed to the mapping logic for now, but remove specific_checks
    let (node_type, expected_data_type, expected_data_map, downcast_method) = match kind_enum {
        ItemKind::Const => (
            // NOTE: Removing lines that will be brough into scope by test invocation site that uses references
            // quote! { syn_parser::parser::nodes::ConstNode },
            quote! { ConstNode },
            quote! { #test_module_path::ExpectedConstData }, // Still need this to find the map
            quote! { #test_module_path::EXPECTED_CONSTS_DATA }, // Still need this
            quote! { as_const },
            // Removed specific_checks quote! block
        ),
        ItemKind::Static => (
            // NOTE: Removing lines that will be brough into scope by test invocation site that uses references
            // quote! { syn_parser::parser::nodes::StaticNode },
            quote! { StaticNode },
            quote! { #test_module_path::ExpectedStaticData }, // Still need this to find the map
            quote! { #test_module_path::EXPECTED_STATICS_DATA }, // Still need this
            quote! { as_static },
            // Removed specific_checks quote! block
        ),
        // Add other ItemKind mappings here, removing the last element (specific_checks)
        // ItemKind::Function => (quote! { FunctionNode }, quote! { ExpectedFunctionData }, ...),
        _ => abort!(
            Span::call_site(),
            "Unsupported ItemKind for #[paranoid_test]: {:?}",
            kind_enum // Use the correct variable name
        ),
    };

    // Convert expected_path Vec<String> to &[&str] literal for ParanoidArgs
    let expected_path_strs: Vec<syn::LitStr> = expected_path_vec
        .iter()
        .map(|s| syn::LitStr::new(s, Span::call_site()))
        .collect();
    let expected_path_slice = quote! { &[#(#expected_path_strs),*] };

    // Convert optional expected_cfg Vec<String> to Option<&[&str]> literal
    let expected_cfg_slice = match expected_cfg_opt_vec {
        Some(cfgs) => {
            let cfg_strs: Vec<syn::LitStr> = cfgs
                .iter()
                .map(|s| syn::LitStr::new(s, Span::call_site()))
                .collect();
            quote! { Some(&[#(#cfg_strs),*]) }
        }
        None => quote! { None },
    };

    // Generate the test function body
    // NOTE: Removing lines that will be brough into scope by test invocation site that uses references
    let expanded = quote! {
        #(#test_fn_attrs)* // Keep original attributes
        #test_fn_vis fn #test_fn_name() -> Result<(), SynParserError> {
            // NOTE: Removing the following dependencies, which are assumed to have been imported
            // in the test file where these macros are invoked.
            // Use fully qualified paths to avoid import issues in generated code
            // Use crate:: instead of syn_parser:: where possible if invoked from syn_parser tests
            // use syn_parser::parser::graph::GraphAccess;
            // use syn_parser::parser::nodes::GraphNode;
            // use syn_parser::parser::nodes::HasAttributes; // Needed for ExpectedNodeData trait bounds
            // use syn_parser::parser::nodes::PrimaryNodeIdTrait; // Needed for to_pid()
            // use #test_module_path::ExpectedNodeData; // Import the base trait

            let _ = env_logger::builder()
                .is_test(true)
                .format_timestamp(None)
                .try_init();

            // 1. Run phases
            let successful_graphs = run_phases_and_collect(#fixture_str);

            // Removing this line, relying on `ParanoidArgs` being in scope at test site.
            // let args = syn_parser::tests::common::ParanoidArgs {
            // 2. Define ParanoidArgs
            let args = ParanoidArgs {
                fixture: #fixture_str,
                relative_file_path: #rel_path_str,
                ident: #ident_str,
                expected_path: #expected_path_slice,
                item_kind: #kind_path, // Use the quoted path to the ItemKind variant
                expected_cfg: #expected_cfg_slice,
            };

            // 3. Get Expected Data
            let expected_data = #expected_data_map
                .get(args.ident)
                .unwrap_or_else(|| panic!("{} not found for ident: {}", stringify!(#expected_data_type), args.ident));

            // 4. Find the target ParsedCodeGraph
            let target_graph_data = successful_graphs
                .iter()
                .find(|pg| pg.file_path.ends_with(args.relative_file_path))
                .unwrap_or_else(|| {
                    panic!(
                        "Target graph '{}' not found for item '{}'.",
                        args.relative_file_path, args.ident
                    )
                });

            args.check_graph(target_graph_data)?; // Log graph context

            // 5. Attempt ID-based lookup and individual field checks
            match args.generate_pid(&successful_graphs) {
                 Ok(test_info) => {
                    match test_info.target_data().find_node_unique(test_info.test_pid().into()) {
                        Ok(node) => {
                            // Downcast based on kind
                            if let Some(specific_node) = node.#downcast_method() {
                                log::info!(target: LOG_TEST_CONST, "Performing individual field checks for '{}' via ID lookup.", args.ident);
                                // Call all check methods from the base trait
                                assert!(expected_data.is_name_match_debug(specific_node), "Name mismatch");
                                assert!(expected_data.is_vis_match_debug(specific_node), "Visibility mismatch");
                                assert!(expected_data.is_attr_match_debug(specific_node), "Attribute mismatch");
                                assert!(expected_data.is_docstring_contains_match_debug(specific_node), "Docstring mismatch");
                                // Call the single check method generated by the derive macro
                                assert!(expected_data.check_all_fields(specific_node), "One or more field checks failed (see logs)");

                                // --- Relation Check (remains the same) ---
                                let expected_path_vec: Vec<String> = args.expected_path.iter().map(|s| s.to_string()).collect();
                                let parent_module = target_graph_data.find_module_by_path_checked(&expected_path_vec)?;
                                let parent_module_id = parent_module.module_id();
                                // Assuming the specific node type has an `id` field that returns the specific typed ID
                                let node_primary_id = specific_node.id.to_pid();

                                let relation_found = target_graph_data.relations().iter().any(|rel| {
                                    matches!(rel, syn_parser::parser::relations::SyntacticRelation::Contains { source, target }
                                        if *source == parent_module_id && *target == node_primary_id)
                                });

                                assert!(
                                    relation_found,
                                    "Missing SyntacticRelation::Contains from parent module {} to node {}",
                                    parent_module_id, specific_node.id // Assuming specific_node has `id`
                                );
                                log::debug!(target: LOG_TEST_CONST, "   Relation Check: Found Contains relation from parent module.");
                                // --- End Relation Check ---

                            } else {
                                panic!("Node found by ID for '{}' was not a {}.", args.ident, stringify!(#node_type));
                            }
                        }
                        Err(e) => {
                             log::warn!(target: LOG_TEST_CONST, "Node lookup by PID '{}' failed for '{}' (Error: {:?}). Proceeding with value-based check only.", test_info.test_pid(), args.ident, e);
                        }
                    }
                }
                Err(e) => {
                     log::warn!(target: LOG_TEST_CONST, "PID generation failed for '{}' (Error: {:?}). Proceeding with value-based check only.", args.ident, e);
                }
            }

            // 6. Perform value-based lookup and count assertion
            log::info!(target: LOG_TEST_CONST, "Performing value-based lookup for '{}'.", args.ident);
            // Use the find_node_by_values method from the trait
            let matching_nodes_by_value: Vec<_> = expected_data.find_node_by_values(target_graph_data).collect();
            assert_eq!(
                matching_nodes_by_value.len(),
                1,
                "Expected to find exactly one {} matching values for '{}'. Found {}.",
                stringify!(#node_type),
                args.ident,
                matching_nodes_by_value.len()
            );

            Ok(())
        }
    };

    expanded.into()
}

// --- Derive Macro Implementation ---

#[proc_macro_error]
#[proc_macro_derive(ExpectedData)]
pub fn derive_expected_data(input: TokenStream) -> TokenStream {
    let input = parse_macro_input!(input as DeriveInput);
    let node_struct_name = &input.ident;

    // Generate the corresponding Expected*Data struct name (e.g., ConstNode -> ExpectedConstData)
    let expected_data_struct_name = format_ident!("Expected{}", node_struct_name);

    // Ensure the input is a struct with named fields
    let fields = match &input.data {
        Data::Struct(s) => match &s.fields {
            Fields::Named(f) => &f.named,
            _ => abort!(
                s.fields.span(),
                "ExpectedData derive only supports structs with named fields"
            ),
        },
        _ => abort!(input.span(), "ExpectedData derive only supports structs"),
    };

    // --- Generate Fields for Expected*Data Struct ---
    let mut expected_fields = Vec::new();
    // --- Generate Implementations for Check Methods ---
    let mut check_methods = Vec::new();
    // --- Generate Filter Steps for find_node_by_values ---
    let mut find_filters = Vec::new();

    // Define the log target (can be customized later)
    let log_target = quote! { "log_test_node" }; // Use a generic target

    for field in fields {
        let field_name = field.ident.as_ref().unwrap(); // We know fields are named
        let field_name_str = field_name.to_string();
        let field_type = &field.ty;

        // Generate check method name (e.g., name -> is_name_match_debug)
        let check_method_name = format_ident!("is_{}_match_debug", field_name);

        // Map original field to expected field and generate checks/filters
        match field_name_str.as_str() {
            "id" | "span" | "fields" | "variants" | "methods" | "imports" | "exports"
            | "generic_params" | "module_def" | "parameters" | "return_type" | "super_traits"
            | "kind" => {
                // Ignore these fields for the Expected*Data struct and checks
            }
            "name" => {
                expected_fields.push(quote! { pub name: &'static str });
                check_methods.push(quote! {
                    fn #check_method_name(&self, node: &N) -> bool {
                        let check = self.name == node.name(); // Assuming N impl GraphNode
                        log::debug!(target: #log_target,
                            "   {} {} | Expected '{}' == Actual '{}'",
                            "Name Match?".to_string().log_step(), check.log_bool(),
                            self.name.log_name(), node.name().log_name()
                        );
                        check
                    }
                });
                find_filters.push(quote! { .filter(|n| n.name() == self.name) });
            }
            "visibility" => {
                expected_fields
                    .push(quote! { pub visibility: syn_parser::parser::types::VisibilityKind }); // Use qualified path
                check_methods.push(quote! {
                    fn #check_method_name(&self, node: &N) -> bool {
                        let check = self.visibility == *node.visibility(); // Assuming N impl GraphNode
                        log::debug!(target: #log_target,
                            "   {} {} | Expected '{}' == Actual '{}'",
                            "Visibility Match?".to_string().log_step(), check.log_bool(),
                            self.visibility.log_vis_debug(), node.visibility().log_vis_debug()
                        );
                        check
                    }
                });
                find_filters.push(quote! { .filter(|n| *n.visibility() == self.visibility) });
            }
            "attributes" => {
                expected_fields
                    .push(quote! { pub attributes: Vec<syn_parser::parser::nodes::Attribute> }); // Use qualified path
                check_methods.push(quote! {
                    fn #check_method_name(&self, node: &N) -> bool {
                        let check = self.attributes == node.attributes(); // Assuming N impl HasAttributes
                        log::debug!(target: #log_target,
                            "   {} {} | Expected '{:?}' == Actual '{:?}'",
                            "Attributes Match?".to_string().log_step(), check.log_bool(),
                            self.attributes, node.attributes()
                        );
                        check
                    }
                });
                find_filters.push(quote! { .filter(|n| n.attributes() == self.attributes) });
            }
            "docstring" => {
                expected_fields.push(quote! { pub docstring_contains: Option<&'static str> });
                check_methods.push(quote! {
                    fn #check_method_name(&self, node: &N) -> bool {
                        let actual_docstring = node.docstring(); // Assuming N impl GraphNode provides docstring() -> Option<&str>
                        let check_passes = match self.docstring_contains {
                            Some(expected_substr) => actual_docstring.map_or(false, |s| s.contains(expected_substr)),
                            None => actual_docstring.is_none(),
                        };
                        log::debug!(target: #log_target,
                            "   {} {} | Expected contains '{:?}' in Actual '{:?}'",
                            "Docstring Contains Match?".to_string().log_step(), check_passes.log_bool(),
                            self.docstring_contains, actual_docstring
                        );
                        check_passes
                    }
                });
                find_filters.push(quote! {
                     .filter(|n| {
                         let actual_docstring = n.docstring();
                         match self.docstring_contains {
                            Some(expected_substr) => actual_docstring.map_or(false, |s| s.contains(expected_substr)),
                            None => actual_docstring.is_none(),
                         }
                     })
                 });
            }
            "cfgs" => {
                expected_fields.push(quote! { pub cfgs: Vec<String> });
                check_methods.push(quote! {
                    fn #check_method_name(&self, node: &N) -> bool {
                        let mut actual_cfgs = node.cfgs().to_vec(); // Assuming N impl GraphNode
                        actual_cfgs.sort_unstable();
                        let mut expected_cfgs_sorted = self.cfgs.clone();
                        expected_cfgs_sorted.sort_unstable();
                        let check = expected_cfgs_sorted == actual_cfgs;
                        log::debug!(target: #log_target,
                            "   {} {} | Expected (sorted) '{:?}' == Actual (sorted) '{:?}'",
                            "CFGs Match?".to_string().log_step(), check.log_bool(),
                            expected_cfgs_sorted, actual_cfgs
                        );
                        check
                    }
                });
                find_filters.push(quote! {
                    .filter(|n| {
                        let mut actual_cfgs = n.cfgs().to_vec();
                        actual_cfgs.sort_unstable();
                        let mut expected_cfgs_sorted = self.cfgs.clone();
                        expected_cfgs_sorted.sort_unstable();
                        expected_cfgs_sorted == actual_cfgs
                    })
                });
            }
            "tracking_hash" => {
                expected_fields.push(quote! { pub tracking_hash_check: bool });
                check_methods.push(quote! {
                    fn #check_method_name(&self, node: &N) -> bool {
                        let actual_check_passes = node.tracking_hash().is_some(); // Assuming N impl GraphNode provides tracking_hash() -> Option<TrackingHash>
                         let check = self.tracking_hash_check == actual_check_passes;
                         log::debug!(target: #log_target,
                            "   {} {} | Expected check pass '{}' == Actual check pass '{}'",
                            "TrackingHash Check Match?".to_string().log_step(), check.log_bool(),
                            self.tracking_hash_check, actual_check_passes
                        );
                        check
                    }
                });
                find_filters.push(
                    quote! { .filter(|n| n.tracking_hash().is_some() == self.tracking_hash_check) },
                );
            }
            "type_id" => {
                expected_fields.push(quote! { pub type_id_check: bool });
                check_methods.push(quote! {
                    fn #check_method_name(&self, node: &N) -> bool {
                        // Need a way to get type_id from N. Add a trait?
                        // Assuming a method `get_type_id()` exists for relevant nodes.
                        let actual_check_passes = node.get_type_id().is_synthetic(); // Assuming N has get_type_id() -> TypeId
                        let check = self.type_id_check == actual_check_passes;
                        log::debug!(target: #log_target,
                            "   {} {} | Expected check pass '{}' == Actual check pass '{}'",
                            "TypeId Check Match?".to_string().log_step(), check.log_bool(),
                            self.type_id_check, actual_check_passes
                        );
                        check
                    }
                });
                find_filters.push(
                    quote! { .filter(|n| n.get_type_id().is_synthetic() == self.type_id_check) },
                );
            }
            "value" if matches!(field_type, Type::Path(p) if p.path.segments.last().is_some_and(|seg| seg.ident == "Option")) =>
            {
                // Handle Option<String> fields like 'value'
                expected_fields.push(quote! { pub value: Option<&'static str> });
                check_methods.push(quote! {
                    fn #check_method_name(&self, node: &N) -> bool {
                        let actual_value = node.get_value(); // Assuming N has get_value() -> Option<&str>
                        let check = self.value == actual_value;
                        log::debug!(target: #log_target,
                            "   {} {} | Expected '{:?}' == Actual '{:?}'",
                            "Value Match?".to_string().log_step(), check.log_bool(),
                            self.value, actual_value
                        );
                        check
                    }
                });
                find_filters.push(quote! { .filter(|n| n.get_value() == self.value) });
            }
            "is_mutable" if matches!(field_type, Type::Path(p) if p.path.segments.last().is_some_and(|seg| seg.ident == "bool")) =>
            {
                // Handle simple bool fields like 'is_mutable'
                expected_fields.push(quote! { pub is_mutable: bool });
                check_methods.push(quote! {
                    fn #check_method_name(&self, node: &N) -> bool {
                        let actual_value = node.is_mutable(); // Assuming N has is_mutable() -> bool
                        let check = self.is_mutable == actual_value;
                        log::debug!(target: #log_target,
                            "   {} {} | Expected '{}' == Actual '{}'",
                            "Is Mutable Match?".to_string().log_step(), check.log_bool(),
                            self.is_mutable, actual_value
                        );
                        check
                    }
                });
                find_filters.push(quote! { .filter(|n| n.is_mutable() == self.is_mutable) });
            }
            // Add more field handlers here...
            _ => {
                // Optionally warn or ignore unknown fields
                // log::warn!("Ignoring field {} in ExpectedData derive", field_name_str);
            }
        }
    }

    // --- Generate the Expected*Data Struct Definition ---
    let expected_struct_def = quote! {
        #[derive(Debug, Clone, PartialEq)] // Add derives as needed
        pub struct #expected_data_struct_name {
            #(#expected_fields),* // Expand generated fields
        }
    };

    // --- Generate the `impl ExpectedNodeData` block ---
    // Determine the node collection field name (e.g., `graph.consts`, `graph.statics`)
    // This requires mapping the node struct name to the field name in CodeGraph.
    let graph_collection_field = match node_struct_name.to_string().as_str() {
        "ConstNode" => quote! { consts },
        "StaticNode" => quote! { statics },
        "FunctionNode" => quote! { functions },
        "StructNode" | "EnumNode" | "UnionNode" | "TypeAliasNode" => quote! { defined_types }, // Need further filtering for these
        "TraitNode" => quote! { traits },
        "ImplNode" => quote! { impls },
        "ModuleNode" => quote! { modules },
        "ImportNode" => quote! { use_statements },
        "MacroNode" => quote! { macros },
        _ => abort!(
            node_struct_name.span(),
            "Cannot determine graph collection field for {}",
            node_struct_name
        ),
    };

    // Special handling for TypeDefNode variants
    let type_def_filter = match node_struct_name.to_string().as_str() {
        "StructNode" => {
            quote! { .filter_map(|n| if let syn_parser::parser::nodes::TypeDefNode::Struct(s) = n { Some(s) } else { None }) }
        }
        "EnumNode" => {
            quote! { .filter_map(|n| if let syn_parser::parser::nodes::TypeDefNode::Enum(e) = n { Some(e) } else { None }) }
        }
        "UnionNode" => {
            quote! { .filter_map(|n| if let syn_parser::parser::nodes::TypeDefNode::Union(u) = n { Some(u) } else { None }) }
        }
        "TypeAliasNode" => {
            quote! { .filter_map(|n| if let syn_parser::parser::nodes::TypeDefNode::TypeAlias(t) = n { Some(t) } else { None }) }
        }
        _ => quote! {}, // No extra filtering needed for other node types
    };

    let expected_node_data_impl = quote! {
        // Use fully qualified paths for traits/structs from syn_parser
        impl crate::ExpectedNodeData<syn_parser::parser::nodes::#node_struct_name> for #expected_data_struct_name {
            fn find_node_by_values<'a>(
                &'a self,
                parsed: &'a syn_parser::parser::ParsedCodeGraph,
            ) -> Box<dyn Iterator<Item = &'a syn_parser::parser::nodes::#node_struct_name> + 'a> {
                 // Import necessary traits for logging/comparison if not already in scope
                 use syn_parser::utils::{LogStyle, LogStyleBool, LogStyleDebug};
                 use syn_parser::parser::nodes::{GraphNode, HasAttributes}; // Assuming these provide necessary methods

                 Box::new(parsed.graph.#graph_collection_field.iter()
                    #type_def_filter // Apply TypeDefNode filtering if necessary
                    // Apply generated filters
                    #(#find_filters)*
                 )
            }

            fn check_all_fields(&self, node: &syn_parser::parser::nodes::#node_struct_name) -> bool {
                 // Import necessary traits for logging/comparison if not already in scope
                 use syn_parser::utils::{LogStyle, LogStyleBool, LogStyleDebug};
                 use syn_parser::parser::nodes::{GraphNode, HasAttributes}; // Assuming these provide necessary methods
                 use ploke_core::IdTrait; // For TypeId::is_synthetic

                // Call all generated check methods defined in the separate impl block
                let mut all_passed = true;
                #( // Iterate through the check_method_name idents generated earlier
                    if !self.#check_method_name(node) { all_passed = false; }
                )*
                all_passed
           }
       }
    };

    // --- Generate the `impl Expected*Data` block with check methods ---
    let expected_data_impl = quote! {
         // Use fully qualified paths for traits/structs from syn_parser
         impl #expected_data_struct_name {
             // Define helper methods needed by check methods (e.g., log_step)
             // Or assume they are brought into scope via use statements where the derive is applied.
             // For simplicity, let's assume LogStyle utils are imported.

             // Define the check methods
             #( // Repeat for each generated check method
                 // Add necessary trait bounds to N if methods assume them (e.g., GraphNode, HasAttributes)
                 fn #check_methods<N: syn_parser::parser::nodes::GraphNode + syn_parser::parser::nodes::HasAttributes + std::fmt::Debug>(&self, node: &N) -> bool {
                     // Implementation generated above
                 }
             )*
         }
    };

    // --- Combine Generated Code ---
    let output = quote! {
        #expected_struct_def
        #expected_node_data_impl
        // #expected_data_impl // Impl block with check methods - currently defined within ExpectedNodeData impl
    };

    output.into()
}
