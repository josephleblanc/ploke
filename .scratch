
Is there some way we can define this struct, `ChatCompReq`, such that the fields from
the `Router` enum wrapped structs appear as fields of `ChatCompReq`?
How do you think we should handle this situation, in which we might need to use a core
struct and then add specific fields for a json request we are sending to an API endpoint?

I'll apply the custom deserialization for `EndpointTag` and remove the AI comments.

crates/ploke-tui/src/llm2/newtypes.rs
```rust
// AI: implement a custom deserialization for this struct, where there may or may not be a
// quantization, but there will be a `provider_name`, e.g. `chutes` is valid, as is `deepinfra/fp4`
// If there is a serde macro helper for this, then you can use that, and if not implement
// serialize/deserialize AI!
/// The "tag" field on endpoint requests in the form {provider_slug}/{quantization} where
/// {provider_slug} is lowercase
#[derive(Clone, Debug)]
pub(crate) struct EndpointTag {
    pub(crate) provider_name: ProviderSlug,
    #[serde(default, skip_serializing_if = "Option::is_none")]
    pub(crate) quantization: Option<Quant>,
}

impl Serialize for EndpointTag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let s = if let Some(q) = self.quantization {
            format!("{}/{}", self.provider_name.as_str(), q.as_str())
        } else {
            self.provider_name.as_str().to_string()
        };
        serializer.serialize_str(&s)
    }
}

impl<'de> Deserialize<'de> for EndpointTag {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EndpointTag;
            fn expecting(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                f.write_str("a string in format \"provider_slug\" or \"provider_slug/quantization\"")
            }
            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                let parts: Vec<&str> = v.split('/').collect();
                match parts.as_slice() {
                    [provider] => Ok(EndpointTag {
                        provider_name: ProviderSlug::new(*provider),
                        quantization: None,
                    }),
                    [provider, quant] => {
                        let quantization = match *quant {
                            "int4" => Quant::int4,
                            "int8" => Quant::int8,
                            "fp4" => Quant::fp4,
                            "fp6" => Quant::fp6,
                            "fp8" => Quant::fp8,
                            "fp16" => Quant::fp16,
                            "bf16" => Quant::bf16,
                            "fp32" => Quant::fp32,
                            "unknown" => Quant::unknown,
                            _ => return Err(E::custom("invalid quantization value")),
                        };
                        Ok(EndpointTag {
                            provider_name: ProviderSlug::new(*provider),
                            quantization: Some(quantization),
                        })
                    }
                    _ => Err(E::custom("invalid format")),
                }
            }
        }
        deserializer.deserialize_str(Visitor)
    }
}
```

I need to add the `as_str` method to the `Quant` enum to support the serialization. Let me add that:

crates/ploke-tui/src/llm2/enums.rs
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Copy, PartialEq, PartialOrd, Eq)]
#[allow(non_camel_case_types)]
pub(crate) enum Quant {
    int4,
    int8,
    fp4,
    fp6,
    fp8,
    fp16,
    bf16,
    fp32,
    unknown
}
```

crates/ploke-tui/src/llm2/enums.rs
```rust
#[derive(Debug, Clone, Serialize, Deserialize, Copy, PartialEq, PartialOrd, Eq)]
#[allow(non_camel_case_types)]
pub(crate) enum Quant {
    int4,
    int8,
    fp4,
    fp6,
    fp8,
    fp16,
    bf16,
    fp32,
    unknown
}

impl Quant {
    pub(crate) fn as_str(&self) -> &'static str {
        match self {
            Quant::int4 => "int4",
            Quant::int8 => "int8",
            Quant::fp4 => "fp4",
            Quant::fp6 => "fp6",
            Quant::fp8 => "fp8",
            Quant::fp16 => "fp16",
            Quant::bf16 => "bf16",
            Quant::fp32 => "fp32",
            Quant::unknown => "unknown",
        }
    }
}
```
