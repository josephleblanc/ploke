use ploke_core::ArcStr;
use serde::{Deserialize, Serialize};
use std::{fmt, str::FromStr, sync::Arc};
use url::Url;

use super::enums::Quant;

// ----- minimal error type -----
#[derive(Debug, thiserror::Error)]
pub(crate) enum IdError {
    #[error("invalid identifier: {0}")]
    Invalid(&'static str),
    #[error("invalid URL")]
    Url(#[from] url::ParseError),
}

macro_rules! newtype_arcstr {
    ($name:ident) => {
        #[derive(Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
        #[serde(transparent)]
        pub(crate) struct $name(ploke_core::ArcStr);
        impl $name {
            pub(crate) fn new(s: impl AsRef<str>) -> Self {
                Self(ploke_core::ArcStr::from(s.as_ref()))
            }
            pub(crate) fn as_str(&self) -> &str {
                &self.0
            }
        }
        impl std::fmt::Debug for $name {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                f.debug_tuple(stringify!($name)).field(&self.0).finish()
            }
        }
    };
}
newtype_arcstr!(ProviderSlug);
newtype_arcstr!(ProviderName);
newtype_arcstr!(ApiKeyEnv);
newtype_arcstr!(EndpointPath);

// ----- strongly-typed string wrappers (easy to swap inner later) -----
#[derive(Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub(crate) struct Author(String);
impl fmt::Debug for Author {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_tuple("Author").field(&self.0).finish()
    }
}
impl Author {
    pub(crate) fn new(s: impl Into<String>) -> Result<Self, IdError> {
        let s = s.into();
        if s.is_empty() || s.contains(' ') {
            return Err(IdError::Invalid("author"));
        }
        Ok(Self(s))
    }
    pub(crate) fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Clone, PartialEq, Eq, Hash, Serialize, Deserialize)]
#[serde(transparent)]
pub(crate) struct ModelSlug(String);
impl fmt::Debug for ModelSlug {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        f.debug_tuple("Slug").field(&self.0).finish()
    }
}
impl ModelSlug {
    pub(crate) fn new(s: impl Into<String>) -> Result<Self, IdError> {
        let s = s.into();
        if s.is_empty() || s.contains(' ') {
            return Err(IdError::Invalid("slug"));
        }
        Ok(Self(s))
    }
    pub(crate) fn as_str(&self) -> &str {
        &self.0
    }
}

#[derive(Clone, PartialEq, Eq, Hash, Serialize, Deserialize, Debug)]
#[serde(transparent)]
/// The canonical id in the form `author/model`, e.g.
pub(crate) struct ModelId(ArcStr);

impl ModelId {
    pub(crate) fn new(s: impl AsRef<str>) -> Self {
        Self(ArcStr::from(s.as_ref()))
    }
    pub(crate) fn as_str(&self) -> &str {
        &self.0
    }
}

/// The "tag" field on endpoint requests in the form {provider_slug}/{quantization} where
/// {provider_slug} is lowercase.
/// - Note: There may or may not be a quantization included
#[derive(Clone, Debug)]
pub(crate) struct EndpointTag {
    pub(crate) provider_name: ProviderSlug,
    pub(crate) quantization: Option<Quant>,
}

impl Serialize for EndpointTag {
    fn serialize<S>(&self, serializer: S) -> Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        let s = if let Some(q) = self.quantization {
            format!("{}/{}", self.provider_name.as_str(), q.as_str())
        } else {
            self.provider_name.as_str().to_string()
        };
        serializer.serialize_str(&s)
    }
}

impl<'de> Deserialize<'de> for EndpointTag {
    fn deserialize<D>(deserializer: D) -> Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EndpointTag;
            fn expecting(&self, f: &mut std::fmt::Formatter) -> std::fmt::Result {
                f.write_str("a string in format \"provider_slug\" or \"provider_slug/quantization\"")
            }
            fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>
            where
                E: serde::de::Error,
            {
                let parts: Vec<&str> = v.split('/').collect();
                match parts.as_slice() {
                    [provider] => Ok(EndpointTag {
                        provider_name: ProviderSlug::new(*provider),
                        quantization: None,
                    }),
                    [provider, quant] => {
                        let quantization = match *quant {
                            "int4" => Quant::int4,
                            "int8" => Quant::int8,
                            "fp4" => Quant::fp4,
                            "fp6" => Quant::fp6,
                            "fp8" => Quant::fp8,
                            "fp16" => Quant::fp16,
                            "bf16" => Quant::bf16,
                            "fp32" => Quant::fp32,
                            "unknown" => Quant::unknown,
                            _ => return Err(E::custom("invalid quantization value")),
                        };
                        Ok(EndpointTag {
                            provider_name: ProviderSlug::new(*provider),
                            quantization: Some(quantization),
                        })
                    }
                    _ => Err(E::custom("invalid format")),
                }
            }
        }
        deserializer.deserialize_str(Visitor)
    }
}


#[derive(Clone, Debug, Serialize, Deserialize)]
pub(crate) struct BaseUrl(#[serde(with = "serde_url")] Url);
mod serde_url {
    use super::*;
    use serde::{Deserialize, Deserializer, Serialize, Serializer, de::Error};
    pub(crate) fn serialize<S: Serializer>(u: &Url, s: S) -> Result<S::Ok, S::Error> {
        s.serialize_str(u.as_str())
    }
    pub(crate) fn deserialize<'de, D: Deserializer<'de>>(d: D) -> Result<Url, D::Error> {
        let s = String::deserialize(d)?;
        Url::parse(&s).map_err(D::Error::custom)
    }
}

impl BaseUrl {
    pub(crate) fn as_url(&self) -> &Url {
        &self.0
    }
}

// Now Transport has only owned data
#[derive(Clone, Debug, Serialize, Deserialize)]
pub(crate) enum Transport {
    OpenRouter {
        base: BaseUrl,
        allow: Vec<ProviderSlug>,
        api_key_env: ApiKeyEnv, // e.g. "OPENROUTER_API_KEY"
    },
    DirectOAI {
        base: BaseUrl,
        chat_path: EndpointPath, // e.g. "chat/completions"
        api_key_env: ApiKeyEnv,  // e.g. "GROQ_API_KEY"
    },
}

#[derive(Clone, Debug, Serialize, Deserialize)]
pub(crate) struct ProviderConfig {
    pub(crate) key: ProviderKey,
    pub(crate) name: ProviderName,
    pub(crate) transport: Transport,
}

// ----- canonical keys -----
// TODO: we need to handle more items like the below, which the `ModelKey` doesn't
// currently handle:
// - nousresearch/deephermes-3-llama-3-8b-preview:free
// - Should turn into a raw curl request like:
//  https://openrouter.ai/api/v1/models/nousresearch/deephermes-3-llama-3-8b-preview%3Afree/endpoints
// - can't add an optional field to `ModelKey` without removing `Hash`, so need to either store it
// in a new `ModelEntry` or store it as an `Extra` field, where `Extra` is another typed wrapper
// that may be empty (annoying to have empty values)
/// Must be of the form `{author}/{slug}:{extra}`
#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub(crate) struct ModelKey {
    /// {author}, e.g. `openai`
    pub(crate) author: Author,
    /// {slug}, e.g. `gpt-5`
    pub(crate) slug: ModelSlug,
    /// `{author}/{slug}`, e.g. `openai/gpt-5`
    pub(crate) id: ModelId,
    /// extra field, where `extra` follows the `:` symbol,
    /// e.g. `nousresearch/deephermes-3-llama-3-8b-preview:free`
    /// where `{author}/{slug}:{extra}`
    /// Note: May be empty
    pub(crate) extra: ModelKeyExtra,
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize, Default)]
pub enum ModelKeyExtra {
    #[serde( rename = "free" )]
    Free,
    #[default]
    Unknown
}

impl ModelKeyExtra {
    pub(crate) fn as_str(&self) {
        match s {
            Self::Free => "free"                                           ,
             Self::Unknown => "unknown"
        }
    }
}

impl From<&str> for ModelKeyExtra {
    fn from(s: &str) -> Self {
        match s {
            "free" =>Self::Free,
            other => Self::Unknown
        }
        
    }
}

impl ModelKey {
    pub(crate) fn from_author_slug(author: &str, slug: &str) -> Result<Self, IdError> {
        Ok(Self {
            author: Author::new(author)?,
            slug: ModelSlug::new(slug)?,
            id: ModelId::new(format!("{}/{}", author, slug)),
            extra: ModelKeyExtra::default(),
        })
    }

    pub(crate) fn from_author_slug_extra(author: &str, slug: &str, extra: &str) -> Result<Self, IdError> {
        Ok(Self {
            author: Author::new(author)?,
            slug: ModelSlug::new(slug)?,
            id: ModelId::new(format!("{}/{}", author, slug)),
            extra: ModelKeyExtra::from(extra),
        })
    }

    pub(crate) fn id(&self) -> String {
        format!("{}/{}", self.author.as_str(), self.slug.as_str())
    }

    /// Input must be of the form `{author}/{model}`
    pub(crate) fn from_string(model_id: String) -> Result<Self, IdError> {
        let mut parts = model_id.trim().split([ '/', ':' ]);
        let author = parts
            .next()
            .ok_or(IdError::Invalid("missing author in model ID"))?;
        let slug = parts
            .next()
            .ok_or(IdError::Invalid("missing model slug in model ID"))?;
        let maybe_extra = parts
            .next().map(ModelKeyExtra::from);

        // Ensure there are no extra parts
        if parts.next().is_some() {
            return Err(IdError::Invalid(
                "model ID should be in format 'author/slug'",
            ));
        }

        Ok(Self {
            author: Author::new(author)?,
            slug: ModelSlug::new(slug)?,
            id: ModelId::new(model_id),
            extra: maybe_extra.unwrap_or_default(),
        })
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub(crate) struct ProviderKey {
    pub(crate) slug: ProviderSlug,
}
impl ProviderKey {
    pub(crate) fn new(slug: &str) -> Result<Self, IdError> {
        Ok(Self {
            slug: ProviderSlug::new(slug),
        })
    }
}

#[derive(Clone, Debug, PartialEq, Eq, Hash, Serialize, Deserialize)]
pub(crate) struct EndpointKey {
    pub(crate) model: ModelKey,
    pub(crate) provider: ProviderKey,
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_model_key_from_author_slug_valid() {
        let key = ModelKey::from_author_slug("openai", "gpt-4").unwrap();
        assert_eq!(key.author.as_str(), "openai");
        assert_eq!(key.slug.as_str(), "gpt-4");
        assert_eq!(key.id(), "openai/gpt-4");
    }

    #[test]
    fn test_model_key_from_string_valid() {
        let key = ModelKey::from_string("anthropic/claude-3".to_string()).unwrap();
        assert_eq!(key.author.as_str(), "anthropic");
        assert_eq!(key.slug.as_str(), "claude-3");
        assert_eq!(key.id(), "anthropic/claude-3");
    }

    #[test]
    fn test_model_key_from_string_invalid_format() {
        // Missing slash
        assert!(ModelKey::from_string("invalid-format".to_string()).is_err());
        
        // Too many slashes
        assert!(ModelKey::from_string("author/model/extra".to_string()).is_err());
        
        // Empty parts
        assert!(ModelKey::from_string("/".to_string()).is_err());
        assert!(ModelKey::from_string("author/".to_string()).is_err());
        assert!(ModelKey::from_string("/model".to_string()).is_err());
        
        // Empty string
        assert!(ModelKey::from_string("".to_string()).is_err());
    }

    #[test]
    fn test_model_key_from_string_whitespace_handling() {
        // Leading/trailing whitespace should be trimmed
        let key = ModelKey::from_string("  openai/gpt-4  ".to_string()).unwrap();
        assert_eq!(key.author.as_str(), "openai");
        assert_eq!(key.slug.as_str(), "gpt-4");
    }

    #[test]
    fn test_model_key_author_slug_validation() {
        // Test invalid author
        assert!(ModelKey::from_author_slug("", "model").is_err());
        assert!(ModelKey::from_author_slug("invalid author", "model").is_err());
        
        // Test invalid slug
        assert!(ModelKey::from_author_slug("author", "").is_err());
        assert!(ModelKey::from_author_slug("author", "invalid slug").is_err());
    }

    #[test]
    fn test_model_key_extra_simple() {
        // Leading/trailing whitespace should be trimmed
        let key = ModelKey::from_string("nousresearch/deephermes-3-llama-3-8b-preview:free".to_string()).unwrap();
        assert_eq!(key.author.as_str(), "nousresearch");
        assert_eq!(key.slug.as_str(), "gpt-4");
        assert_eq!(key.extra.as_str(), "free")
    }
}
