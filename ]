use std::collections::BTreeMap;

use cozo::{DataValue, NamedRows, ScriptMutability};
use itertools::Itertools;
use ploke_core::embeddings::{EmbRelName, EmbeddingSet, EmbeddingSetId};
use ploke_error::Error as PlokeError;
use tracing::info;

use crate::{query::builder::EMBEDDABLE_NODES_NOW, Database, DbError, NodeType, QueryResult};

/// Trait used to extend the database with embeddings-aware methods
pub trait EmbeddingExt {
    /// Counts the code primary node code items that have not yet been embedded.
    ///
    /// Queries the underlying database to determine which nodes have been embedded or not by the
    /// presence/absence of an associated vector for the given embedding set (identified by the
    /// embedding_set_id).
    ///
    /// In the case of nodes being processed into vector embeddings, this function can be used to
    /// determine which nodes have not yet been embedded, while some may already have been
    /// embedded.
    ///
    /// Useful in `ploke-embed` when processing vector embeddings.
    fn count_pending_embeddings(&self, embedding_set_id: &EmbeddingSet) -> Result<usize, DbError>;

    /// Helper function to specifically count unembedded non-files.
    ///
    /// Similar to `count_pending_embeddings`, it is useful when processing vector embeddings in
    /// `ploke-embed`.
    fn count_unembedded_nonfiles(&self, embedding_set_id: &EmbeddingSet) -> Result<usize, DbError>;

    /// Helper function to specifically count unembedded files.
    ///
    // Similar to `count_pending_embeddings`, it is useful when processing vector embeddings in
    // `ploke-embed`
    fn count_unembedded_files(&self, embedding_set_id: &EmbeddingSet) -> Result<usize, DbError>;

    /// Checks for the presence of the embedding info for a given embedding set.
    fn is_embedding_present(&self, embedding_set_id: &EmbeddingSet) -> Result<bool, DbError>;

    fn is_embedding_id_present(&self, embedding_set_id: EmbeddingSetId) -> Result<bool, DbError>;

    fn get_embedding_rel_name(
        &self,
        embedding_set_id: EmbeddingSetId,
    ) -> Result<EmbRelName, DbError>;

    /// Checks whether or not a given vector relation name is already registered in the database.
    ///
    /// Useful when checking that the database has registered the relation for and embedding model.
    ///
    /// e.g. If the relation is present in the database, then the database is ready to register
    /// the embedding vectors for code snippets.
    fn is_relation_registered(&self, relation_name: &EmbRelName) -> Result<bool, DbError>;

    fn script_pending_nodes_rhs(&self, embedding_set: &EmbeddingSet) -> String;

    fn script_embeddable_nodes_now_rhs() -> &'static str;

    #[cfg(feature = "multi_embedding_db")]
    fn get_common_nodes(&self) -> Result<QueryResult, PlokeError>;
}

impl EmbeddingExt for cozo::Db<cozo::MemStorage> {
    fn count_pending_embeddings(&self, embedding_set: &EmbeddingSet) -> Result<usize, DbError> {
        let rel_name = embedding_set.rel_name.to_string().replace('-', "_");
        let pending_nodes_rhs = self.script_pending_nodes_rhs(embedding_set);

        let query = format!("?[count(id)] := {}", pending_nodes_rhs);

        let result = self
            .run_script(
                &query,
                Default::default(),
                cozo::ScriptMutability::Immutable,
            )
            .map_err(|e| DbError::Cozo(e.to_string()))?;

        Database::into_usize(result)
    }

    fn count_unembedded_nonfiles(&self, embedding_set: &EmbeddingSet) -> Result<usize, DbError> {
        let nodes = self.count_pending_embeddings(embedding_set)?;
        let files = self.count_unembedded_files(embedding_set)?;
        let count = nodes.checked_sub(files).ok_or_else(|| {
            DbError::QueryExecution(
                "Invariant violated: more unembedded files than unembedded nodes".into(),
            )
        })?;
        Ok(count)
    }

    fn count_unembedded_files(&self, embedding_set: &EmbeddingSet) -> Result<usize, DbError> {
        let query = format!(
            r#"
unembedded_file_mod[id] := *module{{id}}, *file_mod{{owner_id: id}}, 
!*{embed_rel}{{node_id: id}}

?[count(id)] := unembedded_file_mod[id]
"#,
            embed_rel = embedding_set.rel_name.to_string().replace('-', "_")
        );

        let result = self
            .run_script(
                &query,
                Default::default(),
                cozo::ScriptMutability::Immutable,
            )
            .map_err(|e| DbError::Cozo(e.to_string()))?;

        Database::into_usize(result)
    }

    fn is_embedding_present(&self, embedding_set: &EmbeddingSet) -> Result<bool, DbError> {
        let mut params = BTreeMap::new();
        params.insert(
            "embedding_set_id".into(),
            cozo::DataValue::from(embedding_set.hash_id.into_inner() as i64),
        );

        let get_rel_name_script =
            "?[rel_name] := *embedding_set{id: $embedding_set_id, rel_name @ 'NOW'}";
        let result = self
            .run_script(
                get_rel_name_script,
                params,
                cozo::ScriptMutability::Immutable,
            )
            .map_err(|e| DbError::Cozo(e.to_string()))?;

        result
            .rows
            .first()
            .and_then(|row| row.first())
            .map(|v| v.get_str().is_some())
            .ok_or(DbError::NotFound)
    }

    fn is_embedding_id_present(&self, embedding_set_id: EmbeddingSetId) -> Result<bool, DbError> {
        let mut params = BTreeMap::new();
        params.insert(
            "embedding_set_id".into(),
            cozo::DataValue::from(embedding_set_id.into_inner() as i64),
        );

        let get_rel_name_script =
            "?[rel_name] := *embedding_set{id: $embedding_set_id, rel_name @ 'NOW'}";
        let result = self
            .run_script(
                get_rel_name_script,
                params,
                cozo::ScriptMutability::Immutable,
            )
            .map_err(|e| DbError::Cozo(e.to_string()))?;

        result
            .rows
            .first()
            .and_then(|row| row.first())
            .map(|v| v.get_str().is_some())
            .ok_or(DbError::NotFound)
    }

    fn get_embedding_rel_name(
        &self,
        embedding_set_id: EmbeddingSetId,
    ) -> Result<EmbRelName, DbError> {
        let mut params = BTreeMap::new();
        params.insert(
            "embedding_set_id".into(),
            cozo::DataValue::from(embedding_set_id.into_inner() as i64),
        );

        let get_rel_name_script =
            "?[rel_name] := *embedding_set{id: $embedding_set_id, rel_name @ 'NOW'}";
        let result = self
            .run_script(
                get_rel_name_script,
                params,
                cozo::ScriptMutability::Immutable,
            )
            .map_err(|e| DbError::Cozo(e.to_string()))?;

        result
            .rows
            .first()
            .and_then(|row| row.first())
            .and_then(|v| v.get_str())
            .map(EmbRelName::new_from_str)
            .ok_or(DbError::NotFound)
    }

    fn is_relation_registered(&self, relation_name: &EmbRelName) -> Result<bool, DbError> {
        let rows = self
            .run_script("::relations", BTreeMap::new(), ScriptMutability::Immutable)
            .map_err(|err| DbError::EmbeddingScriptFailure {
                action: "relations_lookup",
                relation: relation_name.clone(),
                details: err.to_string(),
            })?;
        let is_found = rows.rows.iter().any(|row| {
            row.iter().any(|value| {
                value
                    .get_str()
                    .map(|name| name == relation_name.as_ref())
                    .unwrap_or(false)
            })
        });
        Ok(is_found)
    }

    fn script_pending_nodes_rhs(&self, embedding_set: &EmbeddingSet) -> String {
        let rel_name = &embedding_set.rel_name;
        NodeType::primary_nodes()
            .iter()
            .map(|node_type| {
                format!(
                    "(*{node_rel}{{id}}, not *{embed_rel}{{node_id: id}})",
                    node_rel = node_type.relation_str(),
                    embed_rel = &rel_name
                )
            })
            .join(" or ")
    }

    fn script_embeddable_nodes_now_rhs() -> &'static str {
        EMBEDDABLE_NODES_NOW.as_str()
    }


    #[cfg(feature = "multi_embedding_db")]
    fn get_common_nodes(&self) -> Result<QueryResult, PlokeError> {
        let embeddable_nodes_rule = format!( "embeddable[id, name, tracking_hash, span] := {}", Self::script_embeddable_nodes_now_rhs() );
        let script = format!(
            r#"
        {embeddable_nodes_rule}

        ?[id, name, tracking_hash, span] := embeddable[id, name, tracking_hash, span]
        "#
        );

        self.run_script(&script, BTreeMap::new(), ScriptMutability::Immutable)
            .map(QueryResult::from)
            .map_err(DbError::from)
            .map_err(PlokeError::from)
    }
}

    pub fn into_usize(named_rows: Vec<Vec<QueryResult>>) -> Result<usize, DbError> {
        named_rows
            .first()
            .and_then(|row| row.first())
            .and_then(|v| v.get_int())
            .inspect(|v| tracing::info!("the value in first row, first cell is: {:?}", v))
            .map(|n| n as usize)
            .ok_or(DbError::NotFound)
    }


#[cfg(test)]
#[cfg(feature = "multi_embedding_db")]
mod tests {
    // #[cfg(feature = "multi_embedding_db")]
    // fn setup_db() -> Result<(), ploke_error::Error> {
    //     ploke_test_utils::setup_db_full("fixture_nodes")?;
    // }

    use std::collections::BTreeMap;

    use super::*;
    use cozo::{MemStorage, ScriptMutability};
    use ploke_core::embeddings::{
        EmbeddingModelId, EmbeddingProviderSlug, EmbeddingSet, EmbeddingShape,
    };
    use tracing::Level;

    use crate::{
        multi_embedding::{
            db_ext::EmbeddingExt,
            schema::{EmbeddingSetExt, EmbeddingVector},
        },
        Database,
    };
    fn setup_db() -> Result<cozo::Db<MemStorage>, ploke_error::Error> {
        ploke_test_utils::setup_db_full_multi_embedding("fixture_nodes")
    }
    use crate::multi_embedding::schema::CozoEmbeddingSetExt;

    #[test]
    fn multi_pending_embeddings_count_basic() -> Result<(), ploke_error::Error> {
        ploke_test_utils::init_test_tracing(Level::DEBUG);
        // let db = Database::new(ploke_test_utils::setup_db_full("fixture_nodes")?);
        // let db = ploke_test_utils::setup_db_full_multi_embedding("fixture_nodes")?;
        let db = setup_db()?;
        //
        let common_nodes_result = db.get_common_nodes()?;
        let count_common_nodes = into_usize(common_nodes_result);

        info!(?common_nodes_result);

        let embedding_set = EmbeddingSet::new(
            EmbeddingProviderSlug::new_from_str("test_provider/with_slash_in_name"),
            EmbeddingModelId::new_from_str("test_model"),
            EmbeddingShape::new_dims_default(123),
        );
        let create_rel_script = EmbeddingSet::script_create();

        info!("Running script:\n{create_rel_script}");
        let db_result = db
            .run_script(
                create_rel_script,
                BTreeMap::new(),
                ScriptMutability::Mutable,
            )
            .map_err(DbError::from)?;
        info!("db_result: {:?}", db_result.rows);

        let put_rel_script = embedding_set.script_put();
        info!("Running script:\n{put_rel_script}");
        let db_result = db
            .run_script(&put_rel_script, BTreeMap::new(), ScriptMutability::Mutable)
            .map_err(DbError::from)?;
        info!(?db_result.rows);

        let create_vector_script = EmbeddingVector::script_create_from_set(&embedding_set);
        info!("Running script:\n{create_vector_script}");
        let db_result = db
            .run_script(
                &create_vector_script,
                BTreeMap::new(),
                ScriptMutability::Mutable,
            )
            .map_err(DbError::from)?;
        info!(?db_result.rows);

        // check that the relation for the embedding vector has been registered in the database. If
        // true then the database is prepared to receive vector embedding `put` commands.
        let relation_name = embedding_set.relation_name();
        let is_relation_registered = db.is_relation_registered(relation_name)?;
        info!(?is_relation_registered);
        assert!(is_relation_registered, "Expect the relation to be registered after running create_rel_script");

        info!(?db_result.rows);
        let count =
            <cozo::Db<MemStorage> as EmbeddingExt>::count_pending_embeddings(&db, &embedding_set)?;
        info!("Total nodes found without embeddings using new method:\n\t{count}");
        assert_eq!(136, count, "Expect all nodes present (flaky, add better count later)");

        panic!();

        Ok(())
    }
}
